{
  "resolvedId": "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/createRouteData.tsx",
  "transforms": [
    {
      "name": "__load__",
      "result": "import type {\n  Resource,\n  ResourceFetcher, ResourceFetcherInfo, ResourceOptions, Signal\n} from \"solid-js\";\nimport {\n  createResource,\n  onCleanup,\n  startTransition, untrack, useContext\n} from \"solid-js\";\nimport type { ReconcileOptions } from \"solid-js/store\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT, ServerFunctionEvent } from \"../server/types\";\n\ninterface RouteDataEvent extends ServerFunctionEvent {}\n\ntype RouteDataSource<S> = S | false | null | undefined | (() => S | false | null | undefined);\n\ntype RouteDataFetcher<S, T> = (source: S, event: RouteDataEvent) => T | Promise<T>;\n\ntype RouteDataOptions<T, S> = ResourceOptions<T> & {\n  key?: RouteDataSource<S>;\n  reconcileOptions?: ReconcileOptions;\n};\n\nconst resources = new Set<(k: any) => void>();\nconst promises = new Map<any, Promise<any>>();\n\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options?: RouteDataOptions<undefined, S>\n): Resource<T | undefined>;\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S>\n): Resource<T>;\nexport function createRouteData<T, S>(\n  fetcher?: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S> | RouteDataOptions<undefined, S> = {}\n): Resource<T> | Resource<T | undefined> {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n\n  function handleResponse(response: Response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n\n  const resourceFetcher: ResourceFetcher<S, T> = async (key: S) => {\n    try {\n      let event = pageEvent as RouteDataEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n\n      let response = await (fetcher as any).call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e: any | Error) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n\n  function dedupe(fetcher: ResourceFetcher<S, T>): ResourceFetcher<S, T> {\n    return (key: S, info: ResourceFetcherInfo<T>) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n\n      if (key == true) return fetcher(key, info);\n\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info) as Promise<T>;\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n\n  const [resource, { refetch }] = createResource<T, S>(\n    (options.key || true) as RouteDataSource<S>,\n    dedupe(resourceFetcher),\n    {\n      storage: (init: T | undefined) => createDeepSignal(init, options.reconcileOptions),\n      ...options\n    } as any\n  );\n\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n\n  return resource;\n}\n\nexport function refetchRouteData(key?: string | any[] | void) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\n\nfunction createDeepSignal<T>(value: T, options?: ReconcileOptions) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [\n    () => store.value,\n    (v: T) => {\n      const unwrapped = untrack(() => unwrap(store.value));\n      typeof v === \"function\" && (v = v(unwrapped));\n      setStore(\"value\", reconcile(v, options));\n      return store.value;\n    }\n  ] as Signal<T>;\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a: any, b: any) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\n\nfunction ensureQueryKeyArray<V extends any | any[], R = V extends [] ? V : [V]>(value: V): R {\n  return (Array.isArray(value) ? value : [value]) as R;\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a.length && !b.length) return false;\n\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n",
      "start": 1767441590479,
      "end": 1767441590479
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1767441590479,
      "end": 1767441590479,
      "order": "pre"
    },
    {
      "name": "solid",
      "result": "import type { ResourceOptions, Signal } from \"solid-js\";\nimport { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport type {} from \"solid-js/store\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT, ServerFunctionEvent } from \"../server/types\";\ninterface RouteDataEvent extends ServerFunctionEvent {}\ntype RouteDataSource<S> = S | false | null | undefined | (() => S | false | null | undefined);\ntype RouteDataFetcher<S, T> = (source: S, event: RouteDataEvent) => T | Promise<T>;\ntype RouteDataOptions<T, S> = ResourceOptions<T> & {\n  key?: RouteDataSource<S>;\n  reconcileOptions?: ReconcileOptions;\n};\nconst resources = new Set<(k: any) => void>();\nconst promises = new Map<any, Promise<any>>();\nexport function createRouteData<T, S = true>(fetcher: RouteDataFetcher<S, T>, options?: RouteDataOptions<undefined, S>): Resource<T | undefined>;\nexport function createRouteData<T, S = true>(fetcher: RouteDataFetcher<S, T>, options: RouteDataOptions<T, S>): Resource<T>;\nexport function createRouteData<T, S>(fetcher?: RouteDataFetcher<S, T>, options: RouteDataOptions<T, S> | RouteDataOptions<undefined, S> = {}): Resource<T> | Resource<T | undefined> {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response: Response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher: ResourceFetcher<S, T> = async (key: S) => {\n    try {\n      let event = pageEvent as RouteDataEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await (fetcher as any).call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e: any | Error) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher: ResourceFetcher<S, T>): ResourceFetcher<S, T> {\n    return (key: S, info: ResourceFetcherInfo<T>) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true) return fetcher(key, info);\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info) as Promise<T>;\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource<T, S>((options.key || true) as RouteDataSource<S>, dedupe(resourceFetcher), {\n    storage: (init: T | undefined) => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  } as any);\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key?: string | any[] | void) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\nfunction createDeepSignal<T>(value: T, options?: ReconcileOptions) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, (v: T) => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }] as Signal<T>;\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a: any, b: any) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray<V extends any | any[], R = (V extends [] ? V : [V])>(value: V): R {\n  return (Array.isArray(value) ? value : [value]) as R;\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length) return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}",
      "start": 1767441590479,
      "end": 1767441590498,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "ResourceOptions",
          "Signal",
          "createResource",
          "onCleanup",
          "startTransition",
          "untrack",
          "useContext",
          "createStore",
          "reconcile",
          "unwrap",
          "isServer",
          "useNavigate",
          "isRedirectResponse",
          "LocationHeader",
          "ServerContext",
          "FETCH_EVENT",
          "ServerFunctionEvent",
          "RouteDataEvent",
          "RouteDataSource",
          "S",
          "RouteDataFetcher",
          "source",
          "event",
          "T",
          "Promise",
          "RouteDataOptions",
          "key",
          "reconcileOptions",
          "ReconcileOptions",
          "resources",
          "Set",
          "k",
          "promises",
          "Map",
          "createRouteData",
          "fetcher",
          "options",
          "Resource",
          "navigate",
          "pageEvent",
          "handleResponse",
          "response",
          "Response",
          "url",
          "headers",
          "get",
          "startsWith",
          "replace",
          "window",
          "location",
          "href",
          "setStatusCode",
          "status",
          "forEach",
          "head",
          "value",
          "responseHeaders",
          "set",
          "resourceFetcher",
          "ResourceFetcher",
          "Object",
          "freeze",
          "request",
          "env",
          "clientAddress",
          "locals",
          "$type",
          "fetch",
          "call",
          "setTimeout",
          "e",
          "Error",
          "dedupe",
          "info",
          "ResourceFetcherInfo",
          "refetching",
          "partialMatch",
          "promise",
          "finally",
          "delete",
          "resource",
          "refetch",
          "storage",
          "init",
          "createDeepSignal",
          "add",
          "refetchRouteData",
          "store",
          "setStore",
          "v",
          "unwrapped",
          "a",
          "b",
          "partialDeepEqual",
          "ensureQueryKeyArray",
          "V",
          "R",
          "Array",
          "isArray",
          "length",
          "keys",
          "some"
        ],
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/createRouteData.tsx"
        ],
        "sourcesContent": [
          "import type {\n  Resource,\n  ResourceFetcher, ResourceFetcherInfo, ResourceOptions, Signal\n} from \"solid-js\";\nimport {\n  createResource,\n  onCleanup,\n  startTransition, untrack, useContext\n} from \"solid-js\";\nimport type { ReconcileOptions } from \"solid-js/store\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT, ServerFunctionEvent } from \"../server/types\";\n\ninterface RouteDataEvent extends ServerFunctionEvent {}\n\ntype RouteDataSource<S> = S | false | null | undefined | (() => S | false | null | undefined);\n\ntype RouteDataFetcher<S, T> = (source: S, event: RouteDataEvent) => T | Promise<T>;\n\ntype RouteDataOptions<T, S> = ResourceOptions<T> & {\n  key?: RouteDataSource<S>;\n  reconcileOptions?: ReconcileOptions;\n};\n\nconst resources = new Set<(k: any) => void>();\nconst promises = new Map<any, Promise<any>>();\n\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options?: RouteDataOptions<undefined, S>\n): Resource<T | undefined>;\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S>\n): Resource<T>;\nexport function createRouteData<T, S>(\n  fetcher?: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S> | RouteDataOptions<undefined, S> = {}\n): Resource<T> | Resource<T | undefined> {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n\n  function handleResponse(response: Response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n\n  const resourceFetcher: ResourceFetcher<S, T> = async (key: S) => {\n    try {\n      let event = pageEvent as RouteDataEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n\n      let response = await (fetcher as any).call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e: any | Error) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n\n  function dedupe(fetcher: ResourceFetcher<S, T>): ResourceFetcher<S, T> {\n    return (key: S, info: ResourceFetcherInfo<T>) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n\n      if (key == true) return fetcher(key, info);\n\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info) as Promise<T>;\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n\n  const [resource, { refetch }] = createResource<T, S>(\n    (options.key || true) as RouteDataSource<S>,\n    dedupe(resourceFetcher),\n    {\n      storage: (init: T | undefined) => createDeepSignal(init, options.reconcileOptions),\n      ...options\n    } as any\n  );\n\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n\n  return resource;\n}\n\nexport function refetchRouteData(key?: string | any[] | void) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\n\nfunction createDeepSignal<T>(value: T, options?: ReconcileOptions) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [\n    () => store.value,\n    (v: T) => {\n      const unwrapped = untrack(() => unwrap(store.value));\n      typeof v === \"function\" && (v = v(unwrapped));\n      setStore(\"value\", reconcile(v, options));\n      return store.value;\n    }\n  ] as Signal<T>;\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a: any, b: any) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\n\nfunction ensureQueryKeyArray<V extends any | any[], R = V extends [] ? V : [V]>(value: V): R {\n  return (Array.isArray(value) ? value : [value]) as R;\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a.length && !b.length) return false;\n\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n"
        ],
        "mappings": "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",
        "ignoreList": []
      }
    },
    {
      "name": "vite:css",
      "start": 1767441590498,
      "end": 1767441590498,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT } from \"../server/types\";\nconst resources = /* @__PURE__ */ new Set();\nconst promises = /* @__PURE__ */ new Map();\nexport function createRouteData(fetcher, options = {}) {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher = async (key) => {\n    try {\n      let event = pageEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await fetcher.call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher2) {\n    return (key, info) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true)\n        return fetcher2(key, info);\n      let promise = promises.get(key);\n      if (promise)\n        return promise;\n      promise = fetcher2(key, info);\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource(options.key || true, dedupe(resourceFetcher), {\n    storage: (init) => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  });\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key) {\n  if (isServer)\n    throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources)\n      refetch(key);\n  });\n}\nfunction createDeepSignal(value, options) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, (v) => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }];\n}\nfunction partialMatch(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length)\n    return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\n",
      "start": 1767441590498,
      "end": 1767441590567,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/createRouteData.tsx"
        ],
        "sourcesContent": [
          "import type { ResourceOptions, Signal } from \"solid-js\";\nimport { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport type {} from \"solid-js/store\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT, ServerFunctionEvent } from \"../server/types\";\ninterface RouteDataEvent extends ServerFunctionEvent {}\ntype RouteDataSource<S> = S | false | null | undefined | (() => S | false | null | undefined);\ntype RouteDataFetcher<S, T> = (source: S, event: RouteDataEvent) => T | Promise<T>;\ntype RouteDataOptions<T, S> = ResourceOptions<T> & {\n  key?: RouteDataSource<S>;\n  reconcileOptions?: ReconcileOptions;\n};\nconst resources = new Set<(k: any) => void>();\nconst promises = new Map<any, Promise<any>>();\nexport function createRouteData<T, S = true>(fetcher: RouteDataFetcher<S, T>, options?: RouteDataOptions<undefined, S>): Resource<T | undefined>;\nexport function createRouteData<T, S = true>(fetcher: RouteDataFetcher<S, T>, options: RouteDataOptions<T, S>): Resource<T>;\nexport function createRouteData<T, S>(fetcher?: RouteDataFetcher<S, T>, options: RouteDataOptions<T, S> | RouteDataOptions<undefined, S> = {}): Resource<T> | Resource<T | undefined> {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response: Response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher: ResourceFetcher<S, T> = async (key: S) => {\n    try {\n      let event = pageEvent as RouteDataEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await (fetcher as any).call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e: any | Error) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher: ResourceFetcher<S, T>): ResourceFetcher<S, T> {\n    return (key: S, info: ResourceFetcherInfo<T>) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true) return fetcher(key, info);\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info) as Promise<T>;\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource<T, S>((options.key || true) as RouteDataSource<S>, dedupe(resourceFetcher), {\n    storage: (init: T | undefined) => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  } as any);\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key?: string | any[] | void) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\nfunction createDeepSignal<T>(value: T, options?: ReconcileOptions) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, (v: T) => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }] as Signal<T>;\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a: any, b: any) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray<V extends any | any[], R = (V extends [] ? V : [V])>(value: V): R {\n  return (Array.isArray(value) ? value : [value]) as R;\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length) return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}"
        ],
        "mappings": "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",
        "names": [
          "fetcher"
        ]
      }
    },
    {
      "name": "vite:json",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT } from \"../server/types\";\nconst resources = /* @__PURE__ */ new Set();\nconst promises = /* @__PURE__ */ new Map();\nexport function createRouteData(fetcher, options = {}) {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher = async (key) => {\n    try {\n      let event = pageEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await fetcher.call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher2) {\n    return (key, info) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true)\n        return fetcher2(key, info);\n      let promise = promises.get(key);\n      if (promise)\n        return promise;\n      promise = fetcher2(key, info);\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource(options.key || true, dedupe(resourceFetcher), {\n    storage: (init) => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  });\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key) {\n  if (isServer)\n    throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources)\n      refetch(key);\n  });\n}\nfunction createDeepSignal(value, options) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, (v) => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }];\n}\nfunction partialMatch(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length)\n    return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\n",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1767441590567,
      "end": 1767441590567,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/router.tsx\";\nimport { isRedirectResponse, LocationHeader } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/server/responses.ts\";\nimport { ServerContext } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/server/ServerContext.tsx\";\nimport { FETCH_EVENT } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/server/types.tsx\";\nconst resources = /* @__PURE__ */ new Set();\nconst promises = /* @__PURE__ */ new Map();\nexport function createRouteData(fetcher, options = {}) {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher = async (key) => {\n    try {\n      let event = pageEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await fetcher.call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher2) {\n    return (key, info) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true)\n        return fetcher2(key, info);\n      let promise = promises.get(key);\n      if (promise)\n        return promise;\n      promise = fetcher2(key, info);\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource(options.key || true, dedupe(resourceFetcher), {\n    storage: (init) => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  });\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key) {\n  if (isServer)\n    throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources)\n      refetch(key);\n  });\n}\nfunction createDeepSignal(value, options) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, (v) => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }];\n}\nfunction partialMatch(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length)\n    return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\n",
      "start": 1767441590567,
      "end": 1767441590571,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
