{
  "resolvedId": "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/islands/server-router.tsx",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { createContext, JSX, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nexport interface RouteDefinition {\n  path: string;\n  component?: () => JSX.Element;\n  children?: RouteDefinition | RouteDefinition[];\n}\n\nexport type Params = Record<string, string>;\n\nexport interface PathMatch {\n  params: Params;\n  path: string;\n}\n\nexport interface MatchedRoute {\n  id: string;\n  originalPath: string;\n  pattern: string;\n  component: (props: any) => JSX.Element;\n  match: PathMatch;\n  shared: boolean;\n}\n\nexport interface Branch {\n  routes: MatchedRoute[];\n  score: number;\n}\n\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\n\nfunction normalize(path: string) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? (s.startsWith(\"?\") ? s : \"/\" + s) : \"\";\n}\n\nexport function resolvePath(base: string, path: string, from?: string): string | undefined {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\n\nexport function joinPaths(from: string, to: string): string {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\n\nexport function matchPath(path: string, location: string, partial?: boolean): PathMatch | null {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n    return null;\n  }\n\n  const match: PathMatch = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, undefined, { sensitivity: \"base\" }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n\n  return match;\n}\n\nexport function scoreRoute(route: MatchedRoute): number {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce(\n    (score, segment) => score + (segment.startsWith(\":\") ? 2 : 3),\n    segments.length - (splat === undefined ? 0 : 1)\n  );\n}\n\nexport function createMatchedRoute(\n  routeDef: RouteDefinition,\n  base: string,\n  id: string,\n  location: string\n): MatchedRoute | null {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n\n  const { path: originalPath, component = Outlet, children } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\n\nexport function getMatchedBranch(\n  routeDef: RouteDefinition | RouteDefinition[],\n  location: string,\n  stack: MatchedRoute[] = [],\n  branches: Branch[] = []\n): Branch | null {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(\n      def,\n      parent ? parent.pattern : \"/\",\n      parent ? `${parent.id}.${i}` : \"\" + i,\n      location\n    );\n\n    if (route) {\n      stack.push(route);\n\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n\n      stack.pop();\n    }\n  }\n\n  return branches[0] || null;\n}\n\nexport interface RouterContextState {\n  routes: MatchedRoute[];\n  location: string;\n}\n\nexport const RouterContext = createContext<RouterContextState>();\n\nexport const useRouter = () => useContext(RouterContext)!;\n\nexport interface OutletContextState {\n  depth: number;\n  route: MatchedRoute;\n}\n\nexport const OutletContext = createContext<OutletContextState>();\n\nexport const useOutlet = () => useContext(OutletContext);\n\nexport const useRouteParams = () => {\n  const outlet = useOutlet()!;\n  return () => outlet.route.match.params;\n};\n\nexport interface RouterProps {\n  location: string;\n  prevLocation: string;\n  routes: RouteDefinition | RouteDefinition[];\n  children: JSX.Element;\n  out?: any;\n}\n\nexport function Router(props: RouterProps) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n\n  const nextRoutes = next.routes;\n\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (\n        prevRoute &&\n        nextRoute.id === prevRoute.id &&\n        nextRoute.match.path === prevRoute.match.path\n      ) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          // console.log(\"diff rendered\");\n          // const Comp = nextRoute.component;\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n          // diffedRender = (\n          //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n          //     <Comp />\n          //   </outlet-wrapper>\n          // );\n          // return diffedRender;\n        }\n        // Routes are shared\n      } else {\n        // console.log(\"diff rendered\");\n        // const Comp = nextRoute.component;\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n        //console.log(prevRoute, nextRoute);\n        //console.log(`diff render from: ${props.prevLocation} to: ${props.location}`);\n        // diffedRender = (\n        //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n        //     <Comp />\n        //   </outlet-wrapper>\n        // );\n        // return diffedRender;\n      }\n    }\n  }\n\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n\n  return <RouterContext.Provider value={state}>{props.children}</RouterContext.Provider>;\n}\n\nexport function Outlet(props: { children: JSX.Element }) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n\n  return (\n    <>\n      {ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`)}\n      <OutletContext.Provider value={state}>{props.children}</OutletContext.Provider>\n      {ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)}\n    </>\n  );\n}\n",
      "start": 1767441589933,
      "end": 1767441589933
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1767441589933,
      "end": 1767441589933,
      "order": "pre"
    },
    {
      "name": "solid",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nexport interface RouteDefinition {\n  path: string;\n  component?: () => JSX.Element;\n  children?: RouteDefinition | RouteDefinition[];\n}\nexport type Params = Record<string, string>;\nexport interface PathMatch {\n  params: Params;\n  path: string;\n}\nexport interface MatchedRoute {\n  id: string;\n  originalPath: string;\n  pattern: string;\n  component: (props: any) => JSX.Element;\n  match: PathMatch;\n  shared: boolean;\n}\nexport interface Branch {\n  routes: MatchedRoute[];\n  score: number;\n}\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\nfunction normalize(path: string) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? s.startsWith(\"?\") ? s : \"/\" + s : \"\";\n}\nexport function resolvePath(base: string, path: string, from?: string): string | undefined {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\nexport function joinPaths(from: string, to: string): string {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\nexport function matchPath(path: string, location: string, partial?: boolean): PathMatch | null {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {\n    return null;\n  }\n  const match: PathMatch = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, undefined, {\n      sensitivity: \"base\"\n    }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n  return match;\n}\nexport function scoreRoute(route: MatchedRoute): number {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMatchedRoute(routeDef: RouteDefinition, base: string, id: string, location: string): MatchedRoute | null {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n  const {\n    path: originalPath,\n    component = Outlet,\n    children\n  } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\nexport function getMatchedBranch(routeDef: RouteDefinition | RouteDefinition[], location: string, stack: MatchedRoute[] = [], branches: Branch[] = []): Branch | null {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(def, parent ? parent.pattern : \"/\", parent ? `${parent.id}.${i}` : \"\" + i, location);\n    if (route) {\n      stack.push(route);\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n      stack.pop();\n    }\n  }\n  return branches[0] || null;\n}\nexport interface RouterContextState {\n  routes: MatchedRoute[];\n  location: string;\n}\nexport const RouterContext = createContext<RouterContextState>();\nexport const useRouter = () => useContext(RouterContext)!;\nexport interface OutletContextState {\n  depth: number;\n  route: MatchedRoute;\n}\nexport const OutletContext = createContext<OutletContextState>();\nexport const useOutlet = () => useContext(OutletContext);\nexport const useRouteParams = () => {\n  const outlet = useOutlet()!;\n  return () => outlet.route.match.params;\n};\nexport interface RouterProps {\n  location: string;\n  prevLocation: string;\n  routes: RouteDefinition | RouteDefinition[];\n  children: JSX.Element;\n  out?: any;\n}\nexport function Router(props: RouterProps) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n  const nextRoutes = next.routes;\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (prevRoute && nextRoute.id === prevRoute.id && nextRoute.match.path === prevRoute.match.path) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          // console.log(\"diff rendered\");\n          // const Comp = nextRoute.component;\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n          // diffedRender = (\n          //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n          //     <Comp />\n          //   </outlet-wrapper>\n          // );\n          // return diffedRender;\n        }\n        // Routes are shared\n      } else {\n        // console.log(\"diff rendered\");\n        // const Comp = nextRoute.component;\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n        //console.log(prevRoute, nextRoute);\n        //console.log(`diff render from: ${props.prevLocation} to: ${props.location}`);\n        // diffedRender = (\n        //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n        //     <Comp />\n        //   </outlet-wrapper>\n        // );\n        // return diffedRender;\n      }\n    }\n  }\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n  return _$createComponent(RouterContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  });\n}\nexport function Outlet(props: {\n  children: JSX.Element;\n}) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n  return [ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`), _$createComponent(OutletContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  }), ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)];\n}",
      "start": 1767441589933,
      "end": 1767441589971,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "createContext",
          "useContext",
          "ssr",
          "RouteDefinition",
          "path",
          "component",
          "JSX",
          "Element",
          "children",
          "Params",
          "Record",
          "PathMatch",
          "params",
          "MatchedRoute",
          "id",
          "originalPath",
          "pattern",
          "props",
          "match",
          "shared",
          "Branch",
          "routes",
          "score",
          "hasSchemeRegex",
          "trimPathRegex",
          "normalize",
          "s",
          "replace",
          "startsWith",
          "resolvePath",
          "base",
          "from",
          "test",
          "undefined",
          "basePath",
          "fromPath",
          "result",
          "charAt",
          "toLowerCase",
          "indexOf",
          "joinPaths",
          "to",
          "matchPath",
          "location",
          "partial",
          "splat",
          "split",
          "segments",
          "filter",
          "Boolean",
          "len",
          "length",
          "locSegments",
          "lenDiff",
          "i",
          "segment",
          "locSegment",
          "slice",
          "localeCompare",
          "sensitivity",
          "join",
          "scoreRoute",
          "route",
          "reduce",
          "createMatchedRoute",
          "routeDef",
          "hasOwnProperty",
          "Outlet",
          "isLeaf",
          "Array",
          "isArray",
          "getMatchedBranch",
          "stack",
          "branches",
          "routeDefs",
          "def",
          "parent",
          "push",
          "pop",
          "RouterContextState",
          "RouterContext",
          "useRouter",
          "OutletContextState",
          "depth",
          "OutletContext",
          "useOutlet",
          "useRouteParams",
          "outlet",
          "RouterProps",
          "prevLocation",
          "out",
          "Router",
          "next",
          "nextRoutes",
          "prev",
          "prevRoutes",
          "nextRoute",
          "prevRoute",
          "JSON",
          "stringify",
          "replaceOutletId",
          "newOutletId",
          "state",
          "_$createComponent",
          "Provider",
          "value",
          "router"
        ],
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/islands/server-router.tsx"
        ],
        "sourcesContent": [
          "import { createContext, JSX, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nexport interface RouteDefinition {\n  path: string;\n  component?: () => JSX.Element;\n  children?: RouteDefinition | RouteDefinition[];\n}\n\nexport type Params = Record<string, string>;\n\nexport interface PathMatch {\n  params: Params;\n  path: string;\n}\n\nexport interface MatchedRoute {\n  id: string;\n  originalPath: string;\n  pattern: string;\n  component: (props: any) => JSX.Element;\n  match: PathMatch;\n  shared: boolean;\n}\n\nexport interface Branch {\n  routes: MatchedRoute[];\n  score: number;\n}\n\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\n\nfunction normalize(path: string) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? (s.startsWith(\"?\") ? s : \"/\" + s) : \"\";\n}\n\nexport function resolvePath(base: string, path: string, from?: string): string | undefined {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\n\nexport function joinPaths(from: string, to: string): string {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\n\nexport function matchPath(path: string, location: string, partial?: boolean): PathMatch | null {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n    return null;\n  }\n\n  const match: PathMatch = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, undefined, { sensitivity: \"base\" }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n\n  return match;\n}\n\nexport function scoreRoute(route: MatchedRoute): number {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce(\n    (score, segment) => score + (segment.startsWith(\":\") ? 2 : 3),\n    segments.length - (splat === undefined ? 0 : 1)\n  );\n}\n\nexport function createMatchedRoute(\n  routeDef: RouteDefinition,\n  base: string,\n  id: string,\n  location: string\n): MatchedRoute | null {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n\n  const { path: originalPath, component = Outlet, children } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\n\nexport function getMatchedBranch(\n  routeDef: RouteDefinition | RouteDefinition[],\n  location: string,\n  stack: MatchedRoute[] = [],\n  branches: Branch[] = []\n): Branch | null {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(\n      def,\n      parent ? parent.pattern : \"/\",\n      parent ? `${parent.id}.${i}` : \"\" + i,\n      location\n    );\n\n    if (route) {\n      stack.push(route);\n\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n\n      stack.pop();\n    }\n  }\n\n  return branches[0] || null;\n}\n\nexport interface RouterContextState {\n  routes: MatchedRoute[];\n  location: string;\n}\n\nexport const RouterContext = createContext<RouterContextState>();\n\nexport const useRouter = () => useContext(RouterContext)!;\n\nexport interface OutletContextState {\n  depth: number;\n  route: MatchedRoute;\n}\n\nexport const OutletContext = createContext<OutletContextState>();\n\nexport const useOutlet = () => useContext(OutletContext);\n\nexport const useRouteParams = () => {\n  const outlet = useOutlet()!;\n  return () => outlet.route.match.params;\n};\n\nexport interface RouterProps {\n  location: string;\n  prevLocation: string;\n  routes: RouteDefinition | RouteDefinition[];\n  children: JSX.Element;\n  out?: any;\n}\n\nexport function Router(props: RouterProps) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n\n  const nextRoutes = next.routes;\n\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (\n        prevRoute &&\n        nextRoute.id === prevRoute.id &&\n        nextRoute.match.path === prevRoute.match.path\n      ) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          // console.log(\"diff rendered\");\n          // const Comp = nextRoute.component;\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n          // diffedRender = (\n          //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n          //     <Comp />\n          //   </outlet-wrapper>\n          // );\n          // return diffedRender;\n        }\n        // Routes are shared\n      } else {\n        // console.log(\"diff rendered\");\n        // const Comp = nextRoute.component;\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n        //console.log(prevRoute, nextRoute);\n        //console.log(`diff render from: ${props.prevLocation} to: ${props.location}`);\n        // diffedRender = (\n        //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n        //     <Comp />\n        //   </outlet-wrapper>\n        // );\n        // return diffedRender;\n      }\n    }\n  }\n\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n\n  return <RouterContext.Provider value={state}>{props.children}</RouterContext.Provider>;\n}\n\nexport function Outlet(props: { children: JSX.Element }) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n\n  return (\n    <>\n      {ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`)}\n      <OutletContext.Provider value={state}>{props.children}</OutletContext.Provider>\n      {ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)}\n    </>\n  );\n}\n"
        ],
        "mappings": "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",
        "ignoreList": []
      }
    },
    {
      "name": "vite:css",
      "start": 1767441589971,
      "end": 1767441589971,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\nfunction normalize(path) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? s.startsWith(\"?\") ? s : \"/\" + s : \"\";\n}\nexport function resolvePath(base, path, from) {\n  if (hasSchemeRegex.test(path)) {\n    return void 0;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\nexport function joinPaths(from, to) {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\nexport function matchPath(path, location, partial) {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || lenDiff > 0 && splat === void 0 && !partial) {\n    return null;\n  }\n  const match = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, void 0, {\n      sensitivity: \"base\"\n    }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n  return match;\n}\nexport function scoreRoute(route) {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === void 0 ? 0 : 1));\n}\nexport function createMatchedRoute(routeDef, base, id, location) {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n  const {\n    path: originalPath,\n    component = Outlet,\n    children\n  } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\nexport function getMatchedBranch(routeDef, location, stack = [], branches = []) {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(def, parent ? parent.pattern : \"/\", parent ? `${parent.id}.${i}` : \"\" + i, location);\n    if (route) {\n      stack.push(route);\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n      stack.pop();\n    }\n  }\n  return branches[0] || null;\n}\nexport const RouterContext = createContext();\nexport const useRouter = () => useContext(RouterContext);\nexport const OutletContext = createContext();\nexport const useOutlet = () => useContext(OutletContext);\nexport const useRouteParams = () => {\n  const outlet = useOutlet();\n  return () => outlet.route.match.params;\n};\nexport function Router(props) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n  const nextRoutes = next.routes;\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (prevRoute && nextRoute.id === prevRoute.id && nextRoute.match.path === prevRoute.match.path) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        }\n      } else {\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n      }\n    }\n  }\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n  return _$createComponent(RouterContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  });\n}\nexport function Outlet(props) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n  return [ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`), _$createComponent(OutletContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  }), ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)];\n}\n",
      "start": 1767441589971,
      "end": 1767441590009,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/islands/server-router.tsx"
        ],
        "sourcesContent": [
          "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nexport interface RouteDefinition {\n  path: string;\n  component?: () => JSX.Element;\n  children?: RouteDefinition | RouteDefinition[];\n}\nexport type Params = Record<string, string>;\nexport interface PathMatch {\n  params: Params;\n  path: string;\n}\nexport interface MatchedRoute {\n  id: string;\n  originalPath: string;\n  pattern: string;\n  component: (props: any) => JSX.Element;\n  match: PathMatch;\n  shared: boolean;\n}\nexport interface Branch {\n  routes: MatchedRoute[];\n  score: number;\n}\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\nfunction normalize(path: string) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? s.startsWith(\"?\") ? s : \"/\" + s : \"\";\n}\nexport function resolvePath(base: string, path: string, from?: string): string | undefined {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\nexport function joinPaths(from: string, to: string): string {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\nexport function matchPath(path: string, location: string, partial?: boolean): PathMatch | null {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {\n    return null;\n  }\n  const match: PathMatch = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, undefined, {\n      sensitivity: \"base\"\n    }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n  return match;\n}\nexport function scoreRoute(route: MatchedRoute): number {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMatchedRoute(routeDef: RouteDefinition, base: string, id: string, location: string): MatchedRoute | null {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n  const {\n    path: originalPath,\n    component = Outlet,\n    children\n  } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\nexport function getMatchedBranch(routeDef: RouteDefinition | RouteDefinition[], location: string, stack: MatchedRoute[] = [], branches: Branch[] = []): Branch | null {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(def, parent ? parent.pattern : \"/\", parent ? `${parent.id}.${i}` : \"\" + i, location);\n    if (route) {\n      stack.push(route);\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n      stack.pop();\n    }\n  }\n  return branches[0] || null;\n}\nexport interface RouterContextState {\n  routes: MatchedRoute[];\n  location: string;\n}\nexport const RouterContext = createContext<RouterContextState>();\nexport const useRouter = () => useContext(RouterContext)!;\nexport interface OutletContextState {\n  depth: number;\n  route: MatchedRoute;\n}\nexport const OutletContext = createContext<OutletContextState>();\nexport const useOutlet = () => useContext(OutletContext);\nexport const useRouteParams = () => {\n  const outlet = useOutlet()!;\n  return () => outlet.route.match.params;\n};\nexport interface RouterProps {\n  location: string;\n  prevLocation: string;\n  routes: RouteDefinition | RouteDefinition[];\n  children: JSX.Element;\n  out?: any;\n}\nexport function Router(props: RouterProps) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n  const nextRoutes = next.routes;\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (prevRoute && nextRoute.id === prevRoute.id && nextRoute.match.path === prevRoute.match.path) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          // console.log(\"diff rendered\");\n          // const Comp = nextRoute.component;\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n          // diffedRender = (\n          //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n          //     <Comp />\n          //   </outlet-wrapper>\n          // );\n          // return diffedRender;\n        }\n        // Routes are shared\n      } else {\n        // console.log(\"diff rendered\");\n        // const Comp = nextRoute.component;\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n        //console.log(prevRoute, nextRoute);\n        //console.log(`diff render from: ${props.prevLocation} to: ${props.location}`);\n        // diffedRender = (\n        //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n        //     <Comp />\n        //   </outlet-wrapper>\n        // );\n        // return diffedRender;\n      }\n    }\n  }\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n  return _$createComponent(RouterContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  });\n}\nexport function Outlet(props: {\n  children: JSX.Element;\n}) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n  return [ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`), _$createComponent(OutletContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  }), ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)];\n}"
        ],
        "mappings": "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",
        "names": []
      }
    },
    {
      "name": "vite:json",
      "start": 1767441590009,
      "end": 1767441590009,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1767441590009,
      "end": 1767441590009,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1767441590009,
      "end": 1767441590009,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\nfunction normalize(path) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? s.startsWith(\"?\") ? s : \"/\" + s : \"\";\n}\nexport function resolvePath(base, path, from) {\n  if (hasSchemeRegex.test(path)) {\n    return void 0;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\nexport function joinPaths(from, to) {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\nexport function matchPath(path, location, partial) {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || lenDiff > 0 && splat === void 0 && !partial) {\n    return null;\n  }\n  const match = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, void 0, {\n      sensitivity: \"base\"\n    }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n  return match;\n}\nexport function scoreRoute(route) {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === void 0 ? 0 : 1));\n}\nexport function createMatchedRoute(routeDef, base, id, location) {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n  const {\n    path: originalPath,\n    component = Outlet,\n    children\n  } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\nexport function getMatchedBranch(routeDef, location, stack = [], branches = []) {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(def, parent ? parent.pattern : \"/\", parent ? `${parent.id}.${i}` : \"\" + i, location);\n    if (route) {\n      stack.push(route);\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n      stack.pop();\n    }\n  }\n  return branches[0] || null;\n}\nexport const RouterContext = createContext();\nexport const useRouter = () => useContext(RouterContext);\nexport const OutletContext = createContext();\nexport const useOutlet = () => useContext(OutletContext);\nexport const useRouteParams = () => {\n  const outlet = useOutlet();\n  return () => outlet.route.match.params;\n};\nexport function Router(props) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n  const nextRoutes = next.routes;\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (prevRoute && nextRoute.id === prevRoute.id && nextRoute.match.path === prevRoute.match.path) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        }\n      } else {\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n      }\n    }\n  }\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n  return _$createComponent(RouterContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  });\n}\nexport function Outlet(props) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n  return [ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`), _$createComponent(OutletContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  }), ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)];\n}\n",
      "start": 1767441590009,
      "end": 1767441590009,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1767441590010,
      "end": 1767441590010,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1767441590010,
      "end": 1767441590010,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1767441590010,
      "end": 1767441590010,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1767441590010,
      "end": 1767441590010,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1767441590010,
      "end": 1767441590010,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1767441590010,
      "end": 1767441590010,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\nfunction normalize(path) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? s.startsWith(\"?\") ? s : \"/\" + s : \"\";\n}\nexport function resolvePath(base, path, from) {\n  if (hasSchemeRegex.test(path)) {\n    return void 0;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\nexport function joinPaths(from, to) {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\nexport function matchPath(path, location, partial) {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || lenDiff > 0 && splat === void 0 && !partial) {\n    return null;\n  }\n  const match = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, void 0, {\n      sensitivity: \"base\"\n    }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n  return match;\n}\nexport function scoreRoute(route) {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === void 0 ? 0 : 1));\n}\nexport function createMatchedRoute(routeDef, base, id, location) {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n  const {\n    path: originalPath,\n    component = Outlet,\n    children\n  } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\nexport function getMatchedBranch(routeDef, location, stack = [], branches = []) {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(def, parent ? parent.pattern : \"/\", parent ? `${parent.id}.${i}` : \"\" + i, location);\n    if (route) {\n      stack.push(route);\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n      stack.pop();\n    }\n  }\n  return branches[0] || null;\n}\nexport const RouterContext = createContext();\nexport const useRouter = () => useContext(RouterContext);\nexport const OutletContext = createContext();\nexport const useOutlet = () => useContext(OutletContext);\nexport const useRouteParams = () => {\n  const outlet = useOutlet();\n  return () => outlet.route.match.params;\n};\nexport function Router(props) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n  const nextRoutes = next.routes;\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (prevRoute && nextRoute.id === prevRoute.id && nextRoute.match.path === prevRoute.match.path) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        }\n      } else {\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n      }\n    }\n  }\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n  return _$createComponent(RouterContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  });\n}\nexport function Outlet(props) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n  return [ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`), _$createComponent(OutletContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  }), ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)];\n}\n",
      "start": 1767441590010,
      "end": 1767441590010,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
