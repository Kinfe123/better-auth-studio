{
  "resolvedId": "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/Form.tsx",
  "transforms": [
    {
      "name": "__load__",
      "result": "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\n\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\n\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\n\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target:\n      | HTMLFormElement\n      | HTMLButtonElement\n      | HTMLInputElement\n      | FormData\n      | URLSearchParams\n      | { [name: string]: string }\n      | null,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\n\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(\n    mergeProps(\n      {\n        reloadDocument: false,\n        replace: false,\n        method: \"post\" as FormMethod,\n        action: \"/\",\n        encType: \"application/x-www-form-urlencoded\" as FormEncType\n      },\n      _props\n    ),\n    [\n      \"reloadDocument\",\n      \"replace\",\n      \"method\",\n      \"action\",\n      \"encType\",\n      \"onSubmission\",\n      \"onSubmit\",\n      \"children\",\n      \"ref\"\n    ]\n  );\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n\n  createEffect(() => {\n    if (!form) return;\n\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\n        \"button,input[type=submit]\"\n      );\n\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (\n    <form\n      ref={f => {\n        form = f;\n        if (typeof props.ref === \"function\") props.ref(f);\n      }}\n      method={formMethod}\n      action={_props.action}\n      enctype={props.encType}\n      // encType={encType}\n      onSubmit={\n        props.reloadDocument\n          ? undefined\n          : event => {\n              props.onSubmit && props.onSubmit(event);\n              if (event.defaultPrevented) return;\n              event.preventDefault();\n              submit(clickedButtonRef || event.currentTarget, {\n                method: props.method,\n                replace: props.replace\n              });\n              clickedButtonRef = null;\n            }\n      }\n      {...rest}\n    >\n      {props.children}\n    </form>\n  );\n};\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n\nexport function useSubmitImpl(\n  onSubmission: (sub: FormAction<FormData>) => void\n): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any)\n        .submissionTrigger;\n\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (\n      isButtonElement(target) ||\n      (isInputElement(target) && (target.type === \"submit\" || target.type === \"image\"))\n    ) {\n      let form = target.form;\n\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(\n          `Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`\n        );\n      }\n\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n\n    let { protocol, host } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n",
      "start": 1767441590610,
      "end": 1767441590610
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1767441590610,
      "end": 1767441590610,
      "order": "pre"
    },
    {
      "name": "solid",
      "result": "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { escape as _$escape } from \"solid-js/web\";\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n  /**\n   * Specifies the `<form>` to be submitted to the server, a specific\n   * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n   * arbitrary data to submit.\n   *\n   * Note: When using a `<button>` its `name` and `value` will also be\n   * included in the form data that is submitted.\n   */\n  target: HTMLFormElement | HTMLButtonElement | HTMLInputElement | FormData | URLSearchParams | {\n    [name: string]: string;\n  } | null,\n  /**\n   * Options that override the `<form>`'s own attributes. Required when\n   * submitting arbitrary data without a backing `<form>`.\n   */\n  options?: SubmitOptions): void;\n}\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\" as FormMethod,\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\" as FormEncType\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n  createEffect(() => {\n    if (!form) return;\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return _$ssrElement(\"form\", _$mergeProps({\n    method: formMethod,\n    get action() {\n      return _props.action;\n    },\n    get enctype() {\n      return props.encType;\n    }\n  }, rest), () => _$escape(props.children), true);\n};\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\nexport function useSubmitImpl(onSubmission: (sub: FormAction<FormData>) => void): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any).submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}",
      "start": 1767441590610,
      "end": 1767441590627,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "ComponentProps",
          "createEffect",
          "mergeProps",
          "onCleanup",
          "splitProps",
          "FormAction",
          "action",
          "method",
          "formData",
          "Data",
          "encType",
          "FormError",
          "FormImpl",
          "Form",
          "FormEncType",
          "SubmitOptions",
          "FormMethod",
          "replace",
          "SubmitFunction",
          "target",
          "HTMLFormElement",
          "HTMLButtonElement",
          "HTMLInputElement",
          "FormData",
          "URLSearchParams",
          "name",
          "options",
          "FormProps",
          "Omit",
          "reloadDocument",
          "onSubmit",
          "event",
          "SubmitEvent",
          "onSubmission",
          "submission",
          "FormImplProps",
          "onSubmmsion",
          "_props",
          "props",
          "rest",
          "submit",
          "useSubmitImpl",
          "formMethod",
          "toLowerCase",
          "clickedButtonRef",
          "form",
          "handleClick",
          "MouseEvent",
          "HTMLElement",
          "SVGElement",
          "submitButton",
          "closest",
          "type",
          "addEventListener",
          "removeEventListener",
          "_$ssrElement",
          "_$mergeProps",
          "enctype",
          "_$escape",
          "children",
          "sub",
          "isFormElement",
          "submissionTrigger",
          "append",
          "value",
          "isButtonElement",
          "isInputElement",
          "Error",
          "getAttribute",
          "set",
          "isHtmlElement",
          "Object",
          "keys",
          "protocol",
          "host",
          "window",
          "location",
          "url",
          "URL",
          "searchParams",
          "pathname",
          "search",
          "toUpperCase",
          "object",
          "tagName"
        ],
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/Form.tsx"
        ],
        "sourcesContent": [
          "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\n\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\n\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\n\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target:\n      | HTMLFormElement\n      | HTMLButtonElement\n      | HTMLInputElement\n      | FormData\n      | URLSearchParams\n      | { [name: string]: string }\n      | null,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\n\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(\n    mergeProps(\n      {\n        reloadDocument: false,\n        replace: false,\n        method: \"post\" as FormMethod,\n        action: \"/\",\n        encType: \"application/x-www-form-urlencoded\" as FormEncType\n      },\n      _props\n    ),\n    [\n      \"reloadDocument\",\n      \"replace\",\n      \"method\",\n      \"action\",\n      \"encType\",\n      \"onSubmission\",\n      \"onSubmit\",\n      \"children\",\n      \"ref\"\n    ]\n  );\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n\n  createEffect(() => {\n    if (!form) return;\n\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\n        \"button,input[type=submit]\"\n      );\n\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (\n    <form\n      ref={f => {\n        form = f;\n        if (typeof props.ref === \"function\") props.ref(f);\n      }}\n      method={formMethod}\n      action={_props.action}\n      enctype={props.encType}\n      // encType={encType}\n      onSubmit={\n        props.reloadDocument\n          ? undefined\n          : event => {\n              props.onSubmit && props.onSubmit(event);\n              if (event.defaultPrevented) return;\n              event.preventDefault();\n              submit(clickedButtonRef || event.currentTarget, {\n                method: props.method,\n                replace: props.replace\n              });\n              clickedButtonRef = null;\n            }\n      }\n      {...rest}\n    >\n      {props.children}\n    </form>\n  );\n};\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n\nexport function useSubmitImpl(\n  onSubmission: (sub: FormAction<FormData>) => void\n): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any)\n        .submissionTrigger;\n\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (\n      isButtonElement(target) ||\n      (isInputElement(target) && (target.type === \"submit\" || target.type === \"image\"))\n    ) {\n      let form = target.form;\n\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(\n          `Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`\n        );\n      }\n\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n\n    let { protocol, host } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n"
        ],
        "mappings": "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",
        "ignoreList": []
      }
    },
    {
      "name": "vite:css",
      "start": 1767441590627,
      "end": 1767441590627,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { escape as _$escape } from \"solid-js/web\";\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\nexport let FormImpl = (_props) => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\",\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\"\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl((submission) => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let clickedButtonRef = null;\n  let form = null;\n  createEffect(() => {\n    if (!form)\n      return;\n    function handleClick(event) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement))\n        return;\n      let submitButton = event.target.closest(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return _$ssrElement(\"form\", _$mergeProps({\n    method: formMethod,\n    get action() {\n      return _props.action;\n    },\n    get enctype() {\n      return props.encType;\n    }\n  }, rest), () => _$escape(props.children), true);\n};\nexport function useSubmitImpl(onSubmission) {\n  return (target, options = {}) => {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n      let submissionTrigger = options.submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n",
      "start": 1767441590627,
      "end": 1767441590673,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/Form.tsx"
        ],
        "sourcesContent": [
          "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { escape as _$escape } from \"solid-js/web\";\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n  /**\n   * Specifies the `<form>` to be submitted to the server, a specific\n   * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n   * arbitrary data to submit.\n   *\n   * Note: When using a `<button>` its `name` and `value` will also be\n   * included in the form data that is submitted.\n   */\n  target: HTMLFormElement | HTMLButtonElement | HTMLInputElement | FormData | URLSearchParams | {\n    [name: string]: string;\n  } | null,\n  /**\n   * Options that override the `<form>`'s own attributes. Required when\n   * submitting arbitrary data without a backing `<form>`.\n   */\n  options?: SubmitOptions): void;\n}\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\" as FormMethod,\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\" as FormEncType\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n  createEffect(() => {\n    if (!form) return;\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return _$ssrElement(\"form\", _$mergeProps({\n    method: formMethod,\n    get action() {\n      return _props.action;\n    },\n    get enctype() {\n      return props.encType;\n    }\n  }, rest), () => _$escape(props.children), true);\n};\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\nexport function useSubmitImpl(onSubmission: (sub: FormAction<FormData>) => void): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any).submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}"
        ],
        "mappings": "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",
        "names": []
      }
    },
    {
      "name": "vite:json",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { escape as _$escape } from \"solid-js/web\";\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\nexport let FormImpl = (_props) => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\",\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\"\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl((submission) => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let clickedButtonRef = null;\n  let form = null;\n  createEffect(() => {\n    if (!form)\n      return;\n    function handleClick(event) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement))\n        return;\n      let submitButton = event.target.closest(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return _$ssrElement(\"form\", _$mergeProps({\n    method: formMethod,\n    get action() {\n      return _props.action;\n    },\n    get enctype() {\n      return props.encType;\n    }\n  }, rest), () => _$escape(props.children), true);\n};\nexport function useSubmitImpl(onSubmission) {\n  return (target, options = {}) => {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n      let submissionTrigger = options.submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1767441590673,
      "end": 1767441590673,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1767441590673,
      "end": 1767441590674,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1767441590674,
      "end": 1767441590674,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { escape as _$escape } from \"solid-js/web\";\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\nexport { FormError } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/FormError.tsx\";\nexport { FormImpl as Form };\nexport let FormImpl = (_props) => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\",\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\"\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl((submission) => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let clickedButtonRef = null;\n  let form = null;\n  createEffect(() => {\n    if (!form)\n      return;\n    function handleClick(event) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement))\n        return;\n      let submitButton = event.target.closest(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return _$ssrElement(\"form\", _$mergeProps({\n    method: formMethod,\n    get action() {\n      return _props.action;\n    },\n    get enctype() {\n      return props.encType;\n    }\n  }, rest), () => _$escape(props.children), true);\n};\nexport function useSubmitImpl(onSubmission) {\n  return (target, options = {}) => {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n      let submissionTrigger = options.submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n",
      "start": 1767441590674,
      "end": 1767441590674,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
