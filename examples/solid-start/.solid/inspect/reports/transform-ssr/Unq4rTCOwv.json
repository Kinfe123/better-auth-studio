{
  "resolvedId": "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/@solidjs+meta@0.28.7_solid-js@1.9.10/node_modules/@solidjs/meta/dist/index.jsx",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\n// https://html.spec.whatwg.org/multipage/semantics.html#the-title-element\nconst titleTagProperties = [];\nconst metaTagProperties = \n// https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element\n[\"name\", \"http-equiv\", \"content\", \"charset\", \"media\"]\n    // additional properties\n    .concat([\"property\"]);\nconst getTagKey = (tag, properties) => {\n    // pick allowed properties and sort them\n    const tagProps = Object.fromEntries(Object.entries(tag.props)\n        .filter(([k]) => properties.includes(k))\n        .sort());\n    // treat `property` as `name` for meta tags\n    if (Object.hasOwn(tagProps, \"name\") || Object.hasOwn(tagProps, \"property\")) {\n        tagProps.name = tagProps.name || tagProps.property;\n        delete tagProps.property;\n    }\n    // concat tag name and properties as unique key for this tag\n    return tag.tag + JSON.stringify(tagProps);\n};\nconst MetaProvider = props => {\n    if (!isServer && !sharedConfig.context) {\n        const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n        // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n        Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\n    }\n    const cascadedTagInstances = new Map();\n    // TODO: use one element for all tags of the same type, just swap out\n    // where the props get applied\n    function getElement(tag) {\n        if (tag.ref) {\n            return tag.ref;\n        }\n        let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n        if (el) {\n            if (el.tagName.toLowerCase() !== tag.tag) {\n                if (el.parentNode) {\n                    // remove the old tag\n                    el.parentNode.removeChild(el);\n                }\n                // add the new tag\n                el = document.createElement(tag.tag);\n            }\n            // use the old tag\n            el.removeAttribute(\"data-sm\");\n        }\n        else {\n            // create a new tag\n            el = document.createElement(tag.tag);\n        }\n        return el;\n    }\n    const actions = {\n        addClientTag: (tag) => {\n            if (cascadingTags.indexOf(tag.tag) !== -1) {\n                const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n                const tagKey = getTagKey(tag, properties);\n                //  only cascading tags need to be kept as singletons\n                if (!cascadedTagInstances.has(tagKey)) {\n                    cascadedTagInstances.set(tagKey, []);\n                }\n                let instances = cascadedTagInstances.get(tagKey);\n                let index = instances.length;\n                instances = [...instances, tag];\n                // track indices synchronously\n                cascadedTagInstances.set(tagKey, instances);\n                if (!isServer) {\n                    let element = getElement(tag);\n                    tag.ref = element;\n                    spread(element, tag.props);\n                    let lastVisited = null;\n                    for (var i = index - 1; i >= 0; i--) {\n                        if (instances[i] != null) {\n                            lastVisited = instances[i];\n                            break;\n                        }\n                    }\n                    if (element.parentNode != document.head) {\n                        document.head.appendChild(element);\n                    }\n                    if (lastVisited && lastVisited.ref) {\n                        document.head.removeChild(lastVisited.ref);\n                    }\n                }\n                return index;\n            }\n            if (!isServer) {\n                let element = getElement(tag);\n                tag.ref = element;\n                spread(element, tag.props);\n                if (element.parentNode != document.head) {\n                    document.head.appendChild(element);\n                }\n            }\n            return -1;\n        },\n        removeClientTag: (tag, index) => {\n            const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n            const tagKey = getTagKey(tag, properties);\n            if (tag.ref) {\n                const t = cascadedTagInstances.get(tagKey);\n                if (t) {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                        for (let i = index - 1; i >= 0; i--) {\n                            if (t[i] != null) {\n                                document.head.appendChild(t[i].ref);\n                            }\n                        }\n                    }\n                    t[index] = null;\n                    cascadedTagInstances.set(tagKey, t);\n                }\n                else {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                    }\n                }\n            }\n        }\n    };\n    if (isServer) {\n        actions.addServerTag = (tagDesc) => {\n            const { tags = [] } = props;\n            // tweak only cascading tags\n            if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n                const properties = tagDesc.tag === \"title\" ? titleTagProperties : metaTagProperties;\n                const tagDescKey = getTagKey(tagDesc, properties);\n                const index = tags.findIndex(prev => prev.tag === tagDesc.tag && getTagKey(prev, properties) === tagDescKey);\n                if (index !== -1) {\n                    tags.splice(index, 1);\n                }\n            }\n            tags.push(tagDesc);\n        };\n        if (Array.isArray(props.tags) === false) {\n            throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n        }\n    }\n    return <MetaContext.Provider value={actions}>{props.children}</MetaContext.Provider>;\n};\nconst MetaTag = (tag, props, setting) => {\n    const id = createUniqueId();\n    const c = useContext(MetaContext);\n    if (!c)\n        throw new Error(\"<MetaProvider /> should be in the tree\");\n    useHead({\n        tag,\n        props,\n        setting,\n        id,\n        get name() {\n            return props.name || props.property;\n        }\n    });\n    return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n    const { addClientTag, removeClientTag, addServerTag } = useContext(MetaContext);\n    createRenderEffect(() => {\n        if (!isServer) {\n            let index = addClientTag(tagDesc);\n            onCleanup(() => removeClientTag(tagDesc, index));\n        }\n    });\n    if (isServer) {\n        addServerTag(tagDesc);\n        return null;\n    }\n}\nexport function renderTags(tags) {\n    return tags\n        .map(tag => {\n        const keys = Object.keys(tag.props);\n        const props = keys\n            .map(k => k === \"children\"\n            ? \"\"\n            : ` ${k}=\"${\n            // @ts-expect-error\n            escape(tag.props[k], true)}\"`)\n            .join(\"\");\n        const children = tag.props.children;\n        if (tag.setting?.close) {\n            return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${\n            // @ts-expect-error\n            tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n        }\n        return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n    })\n        .join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props, { escape: true, close: true });\nexport const Style = props => MetaTag(\"style\", props, { close: true });\nexport const Meta = props => MetaTag(\"meta\", props);\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => <Link rel=\"stylesheet\" {...props}/>;\n",
      "start": 1767441589983,
      "end": 1767441589983
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1767441589983,
      "end": 1767441589983,
      "order": "pre"
    },
    {
      "name": "solid",
      "result": "import { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\n// https://html.spec.whatwg.org/multipage/semantics.html#the-title-element\nconst titleTagProperties = [];\nconst metaTagProperties =\n// https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element\n[\"name\", \"http-equiv\", \"content\", \"charset\", \"media\"]\n// additional properties\n.concat([\"property\"]);\nconst getTagKey = (tag, properties) => {\n  // pick allowed properties and sort them\n  const tagProps = Object.fromEntries(Object.entries(tag.props).filter(([k]) => properties.includes(k)).sort());\n  // treat `property` as `name` for meta tags\n  if (Object.hasOwn(tagProps, \"name\") || Object.hasOwn(tagProps, \"property\")) {\n    tagProps.name = tagProps.name || tagProps.property;\n    delete tagProps.property;\n  }\n  // concat tag name and properties as unique key for this tag\n  return tag.tag + JSON.stringify(tagProps);\n};\nconst MetaProvider = props => {\n  if (!isServer && !sharedConfig.context) {\n    const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n    // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n    Array.prototype.forEach.call(ssrTags, ssrTag => ssrTag.parentNode.removeChild(ssrTag));\n  }\n  const cascadedTagInstances = new Map();\n  // TODO: use one element for all tags of the same type, just swap out\n  // where the props get applied\n  function getElement(tag) {\n    if (tag.ref) {\n      return tag.ref;\n    }\n    let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n    if (el) {\n      if (el.tagName.toLowerCase() !== tag.tag) {\n        if (el.parentNode) {\n          // remove the old tag\n          el.parentNode.removeChild(el);\n        }\n        // add the new tag\n        el = document.createElement(tag.tag);\n      }\n      // use the old tag\n      el.removeAttribute(\"data-sm\");\n    } else {\n      // create a new tag\n      el = document.createElement(tag.tag);\n    }\n    return el;\n  }\n  const actions = {\n    addClientTag: tag => {\n      if (cascadingTags.indexOf(tag.tag) !== -1) {\n        const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagKey = getTagKey(tag, properties);\n        //  only cascading tags need to be kept as singletons\n        if (!cascadedTagInstances.has(tagKey)) {\n          cascadedTagInstances.set(tagKey, []);\n        }\n        let instances = cascadedTagInstances.get(tagKey);\n        let index = instances.length;\n        instances = [...instances, tag];\n        // track indices synchronously\n        cascadedTagInstances.set(tagKey, instances);\n        if (!isServer) {\n          let element = getElement(tag);\n          tag.ref = element;\n          spread(element, tag.props);\n          let lastVisited = null;\n          for (var i = index - 1; i >= 0; i--) {\n            if (instances[i] != null) {\n              lastVisited = instances[i];\n              break;\n            }\n          }\n          if (element.parentNode != document.head) {\n            document.head.appendChild(element);\n          }\n          if (lastVisited && lastVisited.ref) {\n            document.head.removeChild(lastVisited.ref);\n          }\n        }\n        return index;\n      }\n      if (!isServer) {\n        let element = getElement(tag);\n        tag.ref = element;\n        spread(element, tag.props);\n        if (element.parentNode != document.head) {\n          document.head.appendChild(element);\n        }\n      }\n      return -1;\n    },\n    removeClientTag: (tag, index) => {\n      const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n      const tagKey = getTagKey(tag, properties);\n      if (tag.ref) {\n        const t = cascadedTagInstances.get(tagKey);\n        if (t) {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n            for (let i = index - 1; i >= 0; i--) {\n              if (t[i] != null) {\n                document.head.appendChild(t[i].ref);\n              }\n            }\n          }\n          t[index] = null;\n          cascadedTagInstances.set(tagKey, t);\n        } else {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n          }\n        }\n      }\n    }\n  };\n  if (isServer) {\n    actions.addServerTag = tagDesc => {\n      const {\n        tags = []\n      } = props;\n      // tweak only cascading tags\n      if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n        const properties = tagDesc.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagDescKey = getTagKey(tagDesc, properties);\n        const index = tags.findIndex(prev => prev.tag === tagDesc.tag && getTagKey(prev, properties) === tagDescKey);\n        if (index !== -1) {\n          tags.splice(index, 1);\n        }\n      }\n      tags.push(tagDesc);\n    };\n    if (Array.isArray(props.tags) === false) {\n      throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n    }\n  }\n  return _$createComponent(MetaContext.Provider, {\n    value: actions,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst MetaTag = (tag, props, setting) => {\n  const id = createUniqueId();\n  const c = useContext(MetaContext);\n  if (!c) throw new Error(\"<MetaProvider /> should be in the tree\");\n  useHead({\n    tag,\n    props,\n    setting,\n    id,\n    get name() {\n      return props.name || props.property;\n    }\n  });\n  return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n  const {\n    addClientTag,\n    removeClientTag,\n    addServerTag\n  } = useContext(MetaContext);\n  createRenderEffect(() => {\n    if (!isServer) {\n      let index = addClientTag(tagDesc);\n      onCleanup(() => removeClientTag(tagDesc, index));\n    }\n  });\n  if (isServer) {\n    addServerTag(tagDesc);\n    return null;\n  }\n}\nexport function renderTags(tags) {\n  return tags.map(tag => {\n    const keys = Object.keys(tag.props);\n    const props = keys.map(k => k === \"children\" ? \"\" : ` ${k}=\"${\n    // @ts-expect-error\n    escape(tag.props[k], true)}\"`).join(\"\");\n    const children = tag.props.children;\n    if (tag.setting?.close) {\n      return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${\n      // @ts-expect-error\n      tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n    }\n    return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n  }).join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props, {\n  escape: true,\n  close: true\n});\nexport const Style = props => MetaTag(\"style\", props, {\n  close: true\n});\nexport const Meta = props => MetaTag(\"meta\", props);\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => _$createComponent(Link, _$mergeProps({\n  rel: \"stylesheet\"\n}, props));",
      "start": 1767441589983,
      "end": 1767441590002,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "createContext",
          "createRenderEffect",
          "createUniqueId",
          "onCleanup",
          "sharedConfig",
          "useContext",
          "isServer",
          "spread",
          "escape",
          "MetaContext",
          "cascadingTags",
          "titleTagProperties",
          "metaTagProperties",
          "concat",
          "getTagKey",
          "tag",
          "properties",
          "tagProps",
          "Object",
          "fromEntries",
          "entries",
          "props",
          "filter",
          "k",
          "includes",
          "sort",
          "hasOwn",
          "name",
          "property",
          "JSON",
          "stringify",
          "MetaProvider",
          "context",
          "ssrTags",
          "document",
          "head",
          "querySelectorAll",
          "Array",
          "prototype",
          "forEach",
          "call",
          "ssrTag",
          "parentNode",
          "removeChild",
          "cascadedTagInstances",
          "Map",
          "getElement",
          "ref",
          "el",
          "querySelector",
          "id",
          "tagName",
          "toLowerCase",
          "createElement",
          "removeAttribute",
          "actions",
          "addClientTag",
          "indexOf",
          "tagKey",
          "has",
          "set",
          "instances",
          "get",
          "index",
          "length",
          "element",
          "lastVisited",
          "i",
          "appendChild",
          "removeClientTag",
          "t",
          "addServerTag",
          "tagDesc",
          "tags",
          "tagDescKey",
          "findIndex",
          "prev",
          "splice",
          "push",
          "isArray",
          "Error",
          "_$createComponent",
          "Provider",
          "value",
          "children",
          "MetaTag",
          "setting",
          "c",
          "useHead",
          "renderTags",
          "map",
          "keys",
          "join",
          "close",
          "Title",
          "Style",
          "Meta",
          "Link",
          "Base",
          "Stylesheet",
          "_$mergeProps",
          "rel"
        ],
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/@solidjs+meta@0.28.7_solid-js@1.9.10/node_modules/@solidjs/meta/dist/index.jsx"
        ],
        "sourcesContent": [
          "import { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\n// https://html.spec.whatwg.org/multipage/semantics.html#the-title-element\nconst titleTagProperties = [];\nconst metaTagProperties = \n// https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element\n[\"name\", \"http-equiv\", \"content\", \"charset\", \"media\"]\n    // additional properties\n    .concat([\"property\"]);\nconst getTagKey = (tag, properties) => {\n    // pick allowed properties and sort them\n    const tagProps = Object.fromEntries(Object.entries(tag.props)\n        .filter(([k]) => properties.includes(k))\n        .sort());\n    // treat `property` as `name` for meta tags\n    if (Object.hasOwn(tagProps, \"name\") || Object.hasOwn(tagProps, \"property\")) {\n        tagProps.name = tagProps.name || tagProps.property;\n        delete tagProps.property;\n    }\n    // concat tag name and properties as unique key for this tag\n    return tag.tag + JSON.stringify(tagProps);\n};\nconst MetaProvider = props => {\n    if (!isServer && !sharedConfig.context) {\n        const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n        // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n        Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\n    }\n    const cascadedTagInstances = new Map();\n    // TODO: use one element for all tags of the same type, just swap out\n    // where the props get applied\n    function getElement(tag) {\n        if (tag.ref) {\n            return tag.ref;\n        }\n        let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n        if (el) {\n            if (el.tagName.toLowerCase() !== tag.tag) {\n                if (el.parentNode) {\n                    // remove the old tag\n                    el.parentNode.removeChild(el);\n                }\n                // add the new tag\n                el = document.createElement(tag.tag);\n            }\n            // use the old tag\n            el.removeAttribute(\"data-sm\");\n        }\n        else {\n            // create a new tag\n            el = document.createElement(tag.tag);\n        }\n        return el;\n    }\n    const actions = {\n        addClientTag: (tag) => {\n            if (cascadingTags.indexOf(tag.tag) !== -1) {\n                const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n                const tagKey = getTagKey(tag, properties);\n                //  only cascading tags need to be kept as singletons\n                if (!cascadedTagInstances.has(tagKey)) {\n                    cascadedTagInstances.set(tagKey, []);\n                }\n                let instances = cascadedTagInstances.get(tagKey);\n                let index = instances.length;\n                instances = [...instances, tag];\n                // track indices synchronously\n                cascadedTagInstances.set(tagKey, instances);\n                if (!isServer) {\n                    let element = getElement(tag);\n                    tag.ref = element;\n                    spread(element, tag.props);\n                    let lastVisited = null;\n                    for (var i = index - 1; i >= 0; i--) {\n                        if (instances[i] != null) {\n                            lastVisited = instances[i];\n                            break;\n                        }\n                    }\n                    if (element.parentNode != document.head) {\n                        document.head.appendChild(element);\n                    }\n                    if (lastVisited && lastVisited.ref) {\n                        document.head.removeChild(lastVisited.ref);\n                    }\n                }\n                return index;\n            }\n            if (!isServer) {\n                let element = getElement(tag);\n                tag.ref = element;\n                spread(element, tag.props);\n                if (element.parentNode != document.head) {\n                    document.head.appendChild(element);\n                }\n            }\n            return -1;\n        },\n        removeClientTag: (tag, index) => {\n            const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n            const tagKey = getTagKey(tag, properties);\n            if (tag.ref) {\n                const t = cascadedTagInstances.get(tagKey);\n                if (t) {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                        for (let i = index - 1; i >= 0; i--) {\n                            if (t[i] != null) {\n                                document.head.appendChild(t[i].ref);\n                            }\n                        }\n                    }\n                    t[index] = null;\n                    cascadedTagInstances.set(tagKey, t);\n                }\n                else {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                    }\n                }\n            }\n        }\n    };\n    if (isServer) {\n        actions.addServerTag = (tagDesc) => {\n            const { tags = [] } = props;\n            // tweak only cascading tags\n            if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n                const properties = tagDesc.tag === \"title\" ? titleTagProperties : metaTagProperties;\n                const tagDescKey = getTagKey(tagDesc, properties);\n                const index = tags.findIndex(prev => prev.tag === tagDesc.tag && getTagKey(prev, properties) === tagDescKey);\n                if (index !== -1) {\n                    tags.splice(index, 1);\n                }\n            }\n            tags.push(tagDesc);\n        };\n        if (Array.isArray(props.tags) === false) {\n            throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n        }\n    }\n    return <MetaContext.Provider value={actions}>{props.children}</MetaContext.Provider>;\n};\nconst MetaTag = (tag, props, setting) => {\n    const id = createUniqueId();\n    const c = useContext(MetaContext);\n    if (!c)\n        throw new Error(\"<MetaProvider /> should be in the tree\");\n    useHead({\n        tag,\n        props,\n        setting,\n        id,\n        get name() {\n            return props.name || props.property;\n        }\n    });\n    return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n    const { addClientTag, removeClientTag, addServerTag } = useContext(MetaContext);\n    createRenderEffect(() => {\n        if (!isServer) {\n            let index = addClientTag(tagDesc);\n            onCleanup(() => removeClientTag(tagDesc, index));\n        }\n    });\n    if (isServer) {\n        addServerTag(tagDesc);\n        return null;\n    }\n}\nexport function renderTags(tags) {\n    return tags\n        .map(tag => {\n        const keys = Object.keys(tag.props);\n        const props = keys\n            .map(k => k === \"children\"\n            ? \"\"\n            : ` ${k}=\"${\n            // @ts-expect-error\n            escape(tag.props[k], true)}\"`)\n            .join(\"\");\n        const children = tag.props.children;\n        if (tag.setting?.close) {\n            return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${\n            // @ts-expect-error\n            tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n        }\n        return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n    })\n        .join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props, { escape: true, close: true });\nexport const Style = props => MetaTag(\"style\", props, { close: true });\nexport const Meta = props => MetaTag(\"meta\", props);\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => <Link rel=\"stylesheet\" {...props}/>;\n"
        ],
        "mappings": ";;AAAA,SAASA,aAAa,EAAEC,kBAAkB,EAAEC,cAAc,EAAEC,SAAS,EAAEC,YAAY,EAAEC,UAAU,QAAQ,UAAU;AACjH,SAASC,QAAQ,EAAEC,MAAM,EAAEC,MAAM,QAAQ,cAAc;AACvD,OAAO,MAAMC,WAAW,GAAGT,aAAa,CAAC,CAAC;AAC1C,MAAMU,aAAa,GAAG,CAAC,OAAO,EAAE,MAAM,CAAC;AACvC;AACA,MAAMC,kBAAkB,GAAG,EAAE;AAC7B,MAAMC,iBAAiB;AACvB;AACA,CAAC,MAAM,EAAE,YAAY,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO;AAChD;AAAA,CACCC,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC;AACzB,MAAMC,SAAS,GAAGA,CAACC,GAAG,EAAEC,UAAU,KAAK;EACnC;EACA,MAAMC,QAAQ,GAAGC,MAAM,CAACC,WAAW,CAACD,MAAM,CAACE,OAAO,CAACL,GAAG,CAACM,KAAK,CAAC,CACxDC,MAAM,CAAC,CAAC,CAACC,CAAC,CAAC,KAAKP,UAAU,CAACQ,QAAQ,CAACD,CAAC,CAAC,CAAC,CACvCE,IAAI,CAAC,CAAC,CAAC;EACZ;EACA,IAAIP,MAAM,CAACQ,MAAM,CAACT,QAAQ,EAAE,MAAM,CAAC,IAAIC,MAAM,CAACQ,MAAM,CAACT,QAAQ,EAAE,UAAU,CAAC,EAAE;IACxEA,QAAQ,CAACU,IAAI,GAAGV,QAAQ,CAACU,IAAI,IAAIV,QAAQ,CAACW,QAAQ;IAClD,OAAOX,QAAQ,CAACW,QAAQ;EAC5B;EACA;EACA,OAAOb,GAAG,CAACA,GAAG,GAAGc,IAAI,CAACC,SAAS,CAACb,QAAQ,CAAC;AAC7C,CAAC;AACD,MAAMc,YAAY,GAAGV,KAAK,IAAI;EAC1B,IAAI,CAACf,QAAQ,IAAI,CAACF,YAAY,CAAC4B,OAAO,EAAE;IACpC,MAAMC,OAAO,GAAGC,QAAQ,CAACC,IAAI,CAACC,gBAAgB,CAAC,WAAW,CAAC;IAC3D;IACAC,KAAK,CAACC,SAAS,CAACC,OAAO,CAACC,IAAI,CAACP,OAAO,EAAGQ,MAAM,IAAKA,MAAM,CAACC,UAAU,CAACC,WAAW,CAACF,MAAM,CAAC,CAAC;EAC5F;EACA,MAAMG,oBAAoB,GAAG,IAAIC,GAAG,CAAC,CAAC;EACtC;EACA;EACA,SAASC,UAAUA,CAAC/B,GAAG,EAAE;IACrB,IAAIA,GAAG,CAACgC,GAAG,EAAE;MACT,OAAOhC,GAAG,CAACgC,GAAG;IAClB;IACA,IAAIC,EAAE,GAAGd,QAAQ,CAACe,aAAa,CAAC,aAAalC,GAAG,CAACmC,EAAE,IAAI,CAAC;IACxD,IAAIF,EAAE,EAAE;MACJ,IAAIA,EAAE,CAACG,OAAO,CAACC,WAAW,CAAC,CAAC,KAAKrC,GAAG,CAACA,GAAG,EAAE;QACtC,IAAIiC,EAAE,CAACN,UAAU,EAAE;UACf;UACAM,EAAE,CAACN,UAAU,CAACC,WAAW,CAACK,EAAE,CAAC;QACjC;QACA;QACAA,EAAE,GAAGd,QAAQ,CAACmB,aAAa,CAACtC,GAAG,CAACA,GAAG,CAAC;MACxC;MACA;MACAiC,EAAE,CAACM,eAAe,CAAC,SAAS,CAAC;IACjC,CAAC,MACI;MACD;MACAN,EAAE,GAAGd,QAAQ,CAACmB,aAAa,CAACtC,GAAG,CAACA,GAAG,CAAC;IACxC;IACA,OAAOiC,EAAE;EACb;EACA,MAAMO,OAAO,GAAG;IACZC,YAAY,EAAGzC,GAAG,IAAK;MACnB,IAAIL,aAAa,CAAC+C,OAAO,CAAC1C,GAAG,CAACA,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;QACvC,MAAMC,UAAU,GAAGD,GAAG,CAACA,GAAG,KAAK,OAAO,GAAGJ,kBAAkB,GAAGC,iBAAiB;QAC/E,MAAM8C,MAAM,GAAG5C,SAAS,CAACC,GAAG,EAAEC,UAAU,CAAC;QACzC;QACA,IAAI,CAAC4B,oBAAoB,CAACe,GAAG,CAACD,MAAM,CAAC,EAAE;UACnCd,oBAAoB,CAACgB,GAAG,CAACF,MAAM,EAAE,EAAE,CAAC;QACxC;QACA,IAAIG,SAAS,GAAGjB,oBAAoB,CAACkB,GAAG,CAACJ,MAAM,CAAC;QAChD,IAAIK,KAAK,GAAGF,SAAS,CAACG,MAAM;QAC5BH,SAAS,GAAG,CAAC,GAAGA,SAAS,EAAE9C,GAAG,CAAC;QAC/B;QACA6B,oBAAoB,CAACgB,GAAG,CAACF,MAAM,EAAEG,SAAS,CAAC;QAC3C,IAAI,CAACvD,QAAQ,EAAE;UACX,IAAI2D,OAAO,GAAGnB,UAAU,CAAC/B,GAAG,CAAC;UAC7BA,GAAG,CAACgC,GAAG,GAAGkB,OAAO;UACjB1D,MAAM,CAAC0D,OAAO,EAAElD,GAAG,CAACM,KAAK,CAAC;UAC1B,IAAI6C,WAAW,GAAG,IAAI;UACtB,KAAK,IAAIC,CAAC,GAAGJ,KAAK,GAAG,CAAC,EAAEI,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;YACjC,IAAIN,SAAS,CAACM,CAAC,CAAC,IAAI,IAAI,EAAE;cACtBD,WAAW,GAAGL,SAAS,CAACM,CAAC,CAAC;cAC1B;YACJ;UACJ;UACA,IAAIF,OAAO,CAACvB,UAAU,IAAIR,QAAQ,CAACC,IAAI,EAAE;YACrCD,QAAQ,CAACC,IAAI,CAACiC,WAAW,CAACH,OAAO,CAAC;UACtC;UACA,IAAIC,WAAW,IAAIA,WAAW,CAACnB,GAAG,EAAE;YAChCb,QAAQ,CAACC,IAAI,CAACQ,WAAW,CAACuB,WAAW,CAACnB,GAAG,CAAC;UAC9C;QACJ;QACA,OAAOgB,KAAK;MAChB;MACA,IAAI,CAACzD,QAAQ,EAAE;QACX,IAAI2D,OAAO,GAAGnB,UAAU,CAAC/B,GAAG,CAAC;QAC7BA,GAAG,CAACgC,GAAG,GAAGkB,OAAO;QACjB1D,MAAM,CAAC0D,OAAO,EAAElD,GAAG,CAACM,KAAK,CAAC;QAC1B,IAAI4C,OAAO,CAACvB,UAAU,IAAIR,QAAQ,CAACC,IAAI,EAAE;UACrCD,QAAQ,CAACC,IAAI,CAACiC,WAAW,CAACH,OAAO,CAAC;QACtC;MACJ;MACA,OAAO,CAAC,CAAC;IACb,CAAC;IACDI,eAAe,EAAEA,CAACtD,GAAG,EAAEgD,KAAK,KAAK;MAC7B,MAAM/C,UAAU,GAAGD,GAAG,CAACA,GAAG,KAAK,OAAO,GAAGJ,kBAAkB,GAAGC,iBAAiB;MAC/E,MAAM8C,MAAM,GAAG5C,SAAS,CAACC,GAAG,EAAEC,UAAU,CAAC;MACzC,IAAID,GAAG,CAACgC,GAAG,EAAE;QACT,MAAMuB,CAAC,GAAG1B,oBAAoB,CAACkB,GAAG,CAACJ,MAAM,CAAC;QAC1C,IAAIY,CAAC,EAAE;UACH,IAAIvD,GAAG,CAACgC,GAAG,CAACL,UAAU,EAAE;YACpB3B,GAAG,CAACgC,GAAG,CAACL,UAAU,CAACC,WAAW,CAAC5B,GAAG,CAACgC,GAAG,CAAC;YACvC,KAAK,IAAIoB,CAAC,GAAGJ,KAAK,GAAG,CAAC,EAAEI,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;cACjC,IAAIG,CAAC,CAACH,CAAC,CAAC,IAAI,IAAI,EAAE;gBACdjC,QAAQ,CAACC,IAAI,CAACiC,WAAW,CAACE,CAAC,CAACH,CAAC,CAAC,CAACpB,GAAG,CAAC;cACvC;YACJ;UACJ;UACAuB,CAAC,CAACP,KAAK,CAAC,GAAG,IAAI;UACfnB,oBAAoB,CAACgB,GAAG,CAACF,MAAM,EAAEY,CAAC,CAAC;QACvC,CAAC,MACI;UACD,IAAIvD,GAAG,CAACgC,GAAG,CAACL,UAAU,EAAE;YACpB3B,GAAG,CAACgC,GAAG,CAACL,UAAU,CAACC,WAAW,CAAC5B,GAAG,CAACgC,GAAG,CAAC;UAC3C;QACJ;MACJ;IACJ;EACJ,CAAC;EACD,IAAIzC,QAAQ,EAAE;IACViD,OAAO,CAACgB,YAAY,GAAIC,OAAO,IAAK;MAChC,MAAM;QAAEC,IAAI,GAAG;MAAG,CAAC,GAAGpD,KAAK;MAC3B;MACA,IAAIX,aAAa,CAAC+C,OAAO,CAACe,OAAO,CAACzD,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;QAC3C,MAAMC,UAAU,GAAGwD,OAAO,CAACzD,GAAG,KAAK,OAAO,GAAGJ,kBAAkB,GAAGC,iBAAiB;QACnF,MAAM8D,UAAU,GAAG5D,SAAS,CAAC0D,OAAO,EAAExD,UAAU,CAAC;QACjD,MAAM+C,KAAK,GAAGU,IAAI,CAACE,SAAS,CAACC,IAAI,IAAIA,IAAI,CAAC7D,GAAG,KAAKyD,OAAO,CAACzD,GAAG,IAAID,SAAS,CAAC8D,IAAI,EAAE5D,UAAU,CAAC,KAAK0D,UAAU,CAAC;QAC5G,IAAIX,KAAK,KAAK,CAAC,CAAC,EAAE;UACdU,IAAI,CAACI,MAAM,CAACd,KAAK,EAAE,CAAC,CAAC;QACzB;MACJ;MACAU,IAAI,CAACK,IAAI,CAACN,OAAO,CAAC;IACtB,CAAC;IACD,IAAInC,KAAK,CAAC0C,OAAO,CAAC1D,KAAK,CAACoD,IAAI,CAAC,KAAK,KAAK,EAAE;MACrC,MAAMO,KAAK,CAAC,yDAAyD,CAAC;IAC1E;EACJ;EACA,OAAAC,iBAAA,CAAQxE,WAAW,CAACyE,QAAQ;IAACC,KAAK,EAAE5B,OAAO;IAAA,IAAA6B,SAAA;MAAA,OAAG/D,KAAK,CAAC+D,QAAQ;IAAA;EAAA;AAChE,CAAC;AACD,MAAMC,OAAO,GAAGA,CAACtE,GAAG,EAAEM,KAAK,EAAEiE,OAAO,KAAK;EACrC,MAAMpC,EAAE,GAAGhD,cAAc,CAAC,CAAC;EAC3B,MAAMqF,CAAC,GAAGlF,UAAU,CAACI,WAAW,CAAC;EACjC,IAAI,CAAC8E,CAAC,EACF,MAAM,IAAIP,KAAK,CAAC,wCAAwC,CAAC;EAC7DQ,OAAO,CAAC;IACJzE,GAAG;IACHM,KAAK;IACLiE,OAAO;IACPpC,EAAE;IACF,IAAIvB,IAAIA,CAAA,EAAG;MACP,OAAON,KAAK,CAACM,IAAI,IAAIN,KAAK,CAACO,QAAQ;IACvC;EACJ,CAAC,CAAC;EACF,OAAO,IAAI;AACf,CAAC;AACD,SAASG,YAAY;AACrB,OAAO,SAASyD,OAAOA,CAAChB,OAAO,EAAE;EAC7B,MAAM;IAAEhB,YAAY;IAAEa,eAAe;IAAEE;EAAa,CAAC,GAAGlE,UAAU,CAACI,WAAW,CAAC;EAC/ER,kBAAkB,CAAC,MAAM;IACrB,IAAI,CAACK,QAAQ,EAAE;MACX,IAAIyD,KAAK,GAAGP,YAAY,CAACgB,OAAO,CAAC;MACjCrE,SAAS,CAAC,MAAMkE,eAAe,CAACG,OAAO,EAAET,KAAK,CAAC,CAAC;IACpD;EACJ,CAAC,CAAC;EACF,IAAIzD,QAAQ,EAAE;IACViE,YAAY,CAACC,OAAO,CAAC;IACrB,OAAO,IAAI;EACf;AACJ;AACA,OAAO,SAASiB,UAAUA,CAAChB,IAAI,EAAE;EAC7B,OAAOA,IAAI,CACNiB,GAAG,CAAC3E,GAAG,IAAI;IACZ,MAAM4E,IAAI,GAAGzE,MAAM,CAACyE,IAAI,CAAC5E,GAAG,CAACM,KAAK,CAAC;IACnC,MAAMA,KAAK,GAAGsE,IAAI,CACbD,GAAG,CAACnE,CAAC,IAAIA,CAAC,KAAK,UAAU,GACxB,EAAE,GACF,IAAIA,CAAC;IACP;IACAf,MAAM,CAACO,GAAG,CAACM,KAAK,CAACE,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAC7BqE,IAAI,CAAC,EAAE,CAAC;IACb,MAAMR,QAAQ,GAAGrE,GAAG,CAACM,KAAK,CAAC+D,QAAQ;IACnC,IAAIrE,GAAG,CAACuE,OAAO,EAAEO,KAAK,EAAE;MACpB,OAAO,IAAI9E,GAAG,CAACA,GAAG,aAAaA,GAAG,CAACmC,EAAE,IAAI7B,KAAK;MAC9C;MACAN,GAAG,CAACuE,OAAO,EAAE9E,MAAM,GAAGA,MAAM,CAAC4E,QAAQ,CAAC,GAAGA,QAAQ,IAAI,EAAE,KAAKrE,GAAG,CAACA,GAAG,GAAG;IAC1E;IACA,OAAO,IAAIA,GAAG,CAACA,GAAG,aAAaA,GAAG,CAACmC,EAAE,IAAI7B,KAAK,IAAI;EACtD,CAAC,CAAC,CACGuE,IAAI,CAAC,EAAE,CAAC;AACjB;AACA,OAAO,MAAME,KAAK,GAAGzE,KAAK,IAAIgE,OAAO,CAAC,OAAO,EAAEhE,KAAK,EAAE;EAAEb,MAAM,EAAE,IAAI;EAAEqF,KAAK,EAAE;AAAK,CAAC,CAAC;AACpF,OAAO,MAAME,KAAK,GAAG1E,KAAK,IAAIgE,OAAO,CAAC,OAAO,EAAEhE,KAAK,EAAE;EAAEwE,KAAK,EAAE;AAAK,CAAC,CAAC;AACtE,OAAO,MAAMG,IAAI,GAAG3E,KAAK,IAAIgE,OAAO,CAAC,MAAM,EAAEhE,KAAK,CAAC;AACnD,OAAO,MAAM4E,IAAI,GAAG5E,KAAK,IAAIgE,OAAO,CAAC,MAAM,EAAEhE,KAAK,CAAC;AACnD,OAAO,MAAM6E,IAAI,GAAG7E,KAAK,IAAIgE,OAAO,CAAC,MAAM,EAAEhE,KAAK,CAAC;AACnD,OAAO,MAAM8E,UAAU,GAAG9E,KAAK,IAAA4D,iBAAA,CAAKgB,IAAI,EAAAG,YAAA;EAACC,GAAG;AAAA,GAAkBhF,KAAK,EAAG",
        "ignoreList": []
      }
    },
    {
      "name": "vite:css",
      "start": 1767441590002,
      "end": 1767441590002,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\nconst titleTagProperties = [];\nconst metaTagProperties = (\n  // https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element\n  [\"name\", \"http-equiv\", \"content\", \"charset\", \"media\"].concat([\"property\"])\n);\nconst getTagKey = (tag, properties) => {\n  const tagProps = Object.fromEntries(Object.entries(tag.props).filter(([k]) => properties.includes(k)).sort());\n  if (Object.hasOwn(tagProps, \"name\") || Object.hasOwn(tagProps, \"property\")) {\n    tagProps.name = tagProps.name || tagProps.property;\n    delete tagProps.property;\n  }\n  return tag.tag + JSON.stringify(tagProps);\n};\nconst MetaProvider = (props) => {\n  if (!isServer && !sharedConfig.context) {\n    const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n    Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\n  }\n  const cascadedTagInstances = /* @__PURE__ */ new Map();\n  function getElement(tag) {\n    if (tag.ref) {\n      return tag.ref;\n    }\n    let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n    if (el) {\n      if (el.tagName.toLowerCase() !== tag.tag) {\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        }\n        el = document.createElement(tag.tag);\n      }\n      el.removeAttribute(\"data-sm\");\n    } else {\n      el = document.createElement(tag.tag);\n    }\n    return el;\n  }\n  const actions = {\n    addClientTag: (tag) => {\n      if (cascadingTags.indexOf(tag.tag) !== -1) {\n        const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagKey = getTagKey(tag, properties);\n        if (!cascadedTagInstances.has(tagKey)) {\n          cascadedTagInstances.set(tagKey, []);\n        }\n        let instances = cascadedTagInstances.get(tagKey);\n        let index = instances.length;\n        instances = [...instances, tag];\n        cascadedTagInstances.set(tagKey, instances);\n        if (!isServer) {\n          let element = getElement(tag);\n          tag.ref = element;\n          spread(element, tag.props);\n          let lastVisited = null;\n          for (var i = index - 1; i >= 0; i--) {\n            if (instances[i] != null) {\n              lastVisited = instances[i];\n              break;\n            }\n          }\n          if (element.parentNode != document.head) {\n            document.head.appendChild(element);\n          }\n          if (lastVisited && lastVisited.ref) {\n            document.head.removeChild(lastVisited.ref);\n          }\n        }\n        return index;\n      }\n      if (!isServer) {\n        let element = getElement(tag);\n        tag.ref = element;\n        spread(element, tag.props);\n        if (element.parentNode != document.head) {\n          document.head.appendChild(element);\n        }\n      }\n      return -1;\n    },\n    removeClientTag: (tag, index) => {\n      const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n      const tagKey = getTagKey(tag, properties);\n      if (tag.ref) {\n        const t = cascadedTagInstances.get(tagKey);\n        if (t) {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n            for (let i = index - 1; i >= 0; i--) {\n              if (t[i] != null) {\n                document.head.appendChild(t[i].ref);\n              }\n            }\n          }\n          t[index] = null;\n          cascadedTagInstances.set(tagKey, t);\n        } else {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n          }\n        }\n      }\n    }\n  };\n  if (isServer) {\n    actions.addServerTag = (tagDesc) => {\n      const {\n        tags = []\n      } = props;\n      if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n        const properties = tagDesc.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagDescKey = getTagKey(tagDesc, properties);\n        const index = tags.findIndex((prev) => prev.tag === tagDesc.tag && getTagKey(prev, properties) === tagDescKey);\n        if (index !== -1) {\n          tags.splice(index, 1);\n        }\n      }\n      tags.push(tagDesc);\n    };\n    if (Array.isArray(props.tags) === false) {\n      throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n    }\n  }\n  return _$createComponent(MetaContext.Provider, {\n    value: actions,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst MetaTag = (tag, props, setting) => {\n  const id = createUniqueId();\n  const c = useContext(MetaContext);\n  if (!c)\n    throw new Error(\"<MetaProvider /> should be in the tree\");\n  useHead({\n    tag,\n    props,\n    setting,\n    id,\n    get name() {\n      return props.name || props.property;\n    }\n  });\n  return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n  const {\n    addClientTag,\n    removeClientTag,\n    addServerTag\n  } = useContext(MetaContext);\n  createRenderEffect(() => {\n    if (!isServer) {\n      let index = addClientTag(tagDesc);\n      onCleanup(() => removeClientTag(tagDesc, index));\n    }\n  });\n  if (isServer) {\n    addServerTag(tagDesc);\n    return null;\n  }\n}\nexport function renderTags(tags) {\n  return tags.map((tag) => {\n    const keys = Object.keys(tag.props);\n    const props = keys.map((k) => k === \"children\" ? \"\" : ` ${k}=\"${// @ts-expect-error\n    escape(tag.props[k], true)}\"`).join(\"\");\n    const children = tag.props.children;\n    if (tag.setting?.close) {\n      return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${// @ts-expect-error\n      tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n    }\n    return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n  }).join(\"\");\n}\nexport const Title = (props) => MetaTag(\"title\", props, {\n  escape: true,\n  close: true\n});\nexport const Style = (props) => MetaTag(\"style\", props, {\n  close: true\n});\nexport const Meta = (props) => MetaTag(\"meta\", props);\nexport const Link = (props) => MetaTag(\"link\", props);\nexport const Base = (props) => MetaTag(\"base\", props);\nexport const Stylesheet = (props) => _$createComponent(Link, _$mergeProps({\n  rel: \"stylesheet\"\n}, props));\n",
      "start": 1767441590002,
      "end": 1767441590049,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/@solidjs+meta@0.28.7_solid-js@1.9.10/node_modules/@solidjs/meta/dist/index.jsx"
        ],
        "sourcesContent": [
          "import { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\n// https://html.spec.whatwg.org/multipage/semantics.html#the-title-element\nconst titleTagProperties = [];\nconst metaTagProperties =\n// https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element\n[\"name\", \"http-equiv\", \"content\", \"charset\", \"media\"]\n// additional properties\n.concat([\"property\"]);\nconst getTagKey = (tag, properties) => {\n  // pick allowed properties and sort them\n  const tagProps = Object.fromEntries(Object.entries(tag.props).filter(([k]) => properties.includes(k)).sort());\n  // treat `property` as `name` for meta tags\n  if (Object.hasOwn(tagProps, \"name\") || Object.hasOwn(tagProps, \"property\")) {\n    tagProps.name = tagProps.name || tagProps.property;\n    delete tagProps.property;\n  }\n  // concat tag name and properties as unique key for this tag\n  return tag.tag + JSON.stringify(tagProps);\n};\nconst MetaProvider = props => {\n  if (!isServer && !sharedConfig.context) {\n    const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n    // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n    Array.prototype.forEach.call(ssrTags, ssrTag => ssrTag.parentNode.removeChild(ssrTag));\n  }\n  const cascadedTagInstances = new Map();\n  // TODO: use one element for all tags of the same type, just swap out\n  // where the props get applied\n  function getElement(tag) {\n    if (tag.ref) {\n      return tag.ref;\n    }\n    let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n    if (el) {\n      if (el.tagName.toLowerCase() !== tag.tag) {\n        if (el.parentNode) {\n          // remove the old tag\n          el.parentNode.removeChild(el);\n        }\n        // add the new tag\n        el = document.createElement(tag.tag);\n      }\n      // use the old tag\n      el.removeAttribute(\"data-sm\");\n    } else {\n      // create a new tag\n      el = document.createElement(tag.tag);\n    }\n    return el;\n  }\n  const actions = {\n    addClientTag: tag => {\n      if (cascadingTags.indexOf(tag.tag) !== -1) {\n        const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagKey = getTagKey(tag, properties);\n        //  only cascading tags need to be kept as singletons\n        if (!cascadedTagInstances.has(tagKey)) {\n          cascadedTagInstances.set(tagKey, []);\n        }\n        let instances = cascadedTagInstances.get(tagKey);\n        let index = instances.length;\n        instances = [...instances, tag];\n        // track indices synchronously\n        cascadedTagInstances.set(tagKey, instances);\n        if (!isServer) {\n          let element = getElement(tag);\n          tag.ref = element;\n          spread(element, tag.props);\n          let lastVisited = null;\n          for (var i = index - 1; i >= 0; i--) {\n            if (instances[i] != null) {\n              lastVisited = instances[i];\n              break;\n            }\n          }\n          if (element.parentNode != document.head) {\n            document.head.appendChild(element);\n          }\n          if (lastVisited && lastVisited.ref) {\n            document.head.removeChild(lastVisited.ref);\n          }\n        }\n        return index;\n      }\n      if (!isServer) {\n        let element = getElement(tag);\n        tag.ref = element;\n        spread(element, tag.props);\n        if (element.parentNode != document.head) {\n          document.head.appendChild(element);\n        }\n      }\n      return -1;\n    },\n    removeClientTag: (tag, index) => {\n      const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n      const tagKey = getTagKey(tag, properties);\n      if (tag.ref) {\n        const t = cascadedTagInstances.get(tagKey);\n        if (t) {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n            for (let i = index - 1; i >= 0; i--) {\n              if (t[i] != null) {\n                document.head.appendChild(t[i].ref);\n              }\n            }\n          }\n          t[index] = null;\n          cascadedTagInstances.set(tagKey, t);\n        } else {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n          }\n        }\n      }\n    }\n  };\n  if (isServer) {\n    actions.addServerTag = tagDesc => {\n      const {\n        tags = []\n      } = props;\n      // tweak only cascading tags\n      if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n        const properties = tagDesc.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagDescKey = getTagKey(tagDesc, properties);\n        const index = tags.findIndex(prev => prev.tag === tagDesc.tag && getTagKey(prev, properties) === tagDescKey);\n        if (index !== -1) {\n          tags.splice(index, 1);\n        }\n      }\n      tags.push(tagDesc);\n    };\n    if (Array.isArray(props.tags) === false) {\n      throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n    }\n  }\n  return _$createComponent(MetaContext.Provider, {\n    value: actions,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst MetaTag = (tag, props, setting) => {\n  const id = createUniqueId();\n  const c = useContext(MetaContext);\n  if (!c) throw new Error(\"<MetaProvider /> should be in the tree\");\n  useHead({\n    tag,\n    props,\n    setting,\n    id,\n    get name() {\n      return props.name || props.property;\n    }\n  });\n  return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n  const {\n    addClientTag,\n    removeClientTag,\n    addServerTag\n  } = useContext(MetaContext);\n  createRenderEffect(() => {\n    if (!isServer) {\n      let index = addClientTag(tagDesc);\n      onCleanup(() => removeClientTag(tagDesc, index));\n    }\n  });\n  if (isServer) {\n    addServerTag(tagDesc);\n    return null;\n  }\n}\nexport function renderTags(tags) {\n  return tags.map(tag => {\n    const keys = Object.keys(tag.props);\n    const props = keys.map(k => k === \"children\" ? \"\" : ` ${k}=\"${\n    // @ts-expect-error\n    escape(tag.props[k], true)}\"`).join(\"\");\n    const children = tag.props.children;\n    if (tag.setting?.close) {\n      return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${\n      // @ts-expect-error\n      tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n    }\n    return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n  }).join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props, {\n  escape: true,\n  close: true\n});\nexport const Style = props => MetaTag(\"style\", props, {\n  close: true\n});\nexport const Meta = props => MetaTag(\"meta\", props);\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => _$createComponent(Link, _$mergeProps({\n  rel: \"stylesheet\"\n}, props));"
        ],
        "mappings": "AAAA,SAAS,cAAc,oBAAoB;AAC3C,SAAS,mBAAmB,yBAAyB;AACrD,SAAS,eAAe,oBAAoB,gBAAgB,WAAW,cAAc,kBAAkB;AACvG,SAAS,UAAU,QAAQ,cAAc;AAClC,aAAM,cAAc,cAAc;AACzC,MAAM,gBAAgB,CAAC,SAAS,MAAM;AAEtC,MAAM,qBAAqB,CAAC;AAC5B,MAAM;AAAA;AAAA,EAEN,CAAC,QAAQ,cAAc,WAAW,WAAW,OAAO,EAEnD,OAAO,CAAC,UAAU,CAAC;AAAA;AACpB,MAAM,YAAY,CAAC,KAAK,eAAe;AAErC,QAAM,WAAW,OAAO,YAAY,OAAO,QAAQ,IAAI,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,MAAM,WAAW,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;AAE5G,MAAI,OAAO,OAAO,UAAU,MAAM,KAAK,OAAO,OAAO,UAAU,UAAU,GAAG;AAC1E,aAAS,OAAO,SAAS,QAAQ,SAAS;AAC1C,WAAO,SAAS;AAAA,EAClB;AAEA,SAAO,IAAI,MAAM,KAAK,UAAU,QAAQ;AAC1C;AACA,MAAM,eAAe,WAAS;AAC5B,MAAI,CAAC,YAAY,CAAC,aAAa,SAAS;AACtC,UAAM,UAAU,SAAS,KAAK,iBAAiB,WAAW;AAE1D,UAAM,UAAU,QAAQ,KAAK,SAAS,YAAU,OAAO,WAAW,YAAY,MAAM,CAAC;AAAA,EACvF;AACA,QAAM,uBAAuB,oBAAI,IAAI;AAGrC,WAAS,WAAW,KAAK;AACvB,QAAI,IAAI,KAAK;AACX,aAAO,IAAI;AAAA,IACb;AACA,QAAI,KAAK,SAAS,cAAc,aAAa,IAAI,EAAE,IAAI;AACvD,QAAI,IAAI;AACN,UAAI,GAAG,QAAQ,YAAY,MAAM,IAAI,KAAK;AACxC,YAAI,GAAG,YAAY;AAEjB,aAAG,WAAW,YAAY,EAAE;AAAA,QAC9B;AAEA,aAAK,SAAS,cAAc,IAAI,GAAG;AAAA,MACrC;AAEA,SAAG,gBAAgB,SAAS;AAAA,IAC9B,OAAO;AAEL,WAAK,SAAS,cAAc,IAAI,GAAG;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AACA,QAAM,UAAU;AAAA,IACd,cAAc,SAAO;AACnB,UAAI,cAAc,QAAQ,IAAI,GAAG,MAAM,IAAI;AACzC,cAAM,aAAa,IAAI,QAAQ,UAAU,qBAAqB;AAC9D,cAAM,SAAS,UAAU,KAAK,UAAU;AAExC,YAAI,CAAC,qBAAqB,IAAI,MAAM,GAAG;AACrC,+BAAqB,IAAI,QAAQ,CAAC,CAAC;AAAA,QACrC;AACA,YAAI,YAAY,qBAAqB,IAAI,MAAM;AAC/C,YAAI,QAAQ,UAAU;AACtB,oBAAY,CAAC,GAAG,WAAW,GAAG;AAE9B,6BAAqB,IAAI,QAAQ,SAAS;AAC1C,YAAI,CAAC,UAAU;AACb,cAAI,UAAU,WAAW,GAAG;AAC5B,cAAI,MAAM;AACV,iBAAO,SAAS,IAAI,KAAK;AACzB,cAAI,cAAc;AAClB,mBAAS,IAAI,QAAQ,GAAG,KAAK,GAAG,KAAK;AACnC,gBAAI,UAAU,CAAC,KAAK,MAAM;AACxB,4BAAc,UAAU,CAAC;AACzB;AAAA,YACF;AAAA,UACF;AACA,cAAI,QAAQ,cAAc,SAAS,MAAM;AACvC,qBAAS,KAAK,YAAY,OAAO;AAAA,UACnC;AACA,cAAI,eAAe,YAAY,KAAK;AAClC,qBAAS,KAAK,YAAY,YAAY,GAAG;AAAA,UAC3C;AAAA,QACF;AACA,eAAO;AAAA,MACT;AACA,UAAI,CAAC,UAAU;AACb,YAAI,UAAU,WAAW,GAAG;AAC5B,YAAI,MAAM;AACV,eAAO,SAAS,IAAI,KAAK;AACzB,YAAI,QAAQ,cAAc,SAAS,MAAM;AACvC,mBAAS,KAAK,YAAY,OAAO;AAAA,QACnC;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,iBAAiB,CAAC,KAAK,UAAU;AAC/B,YAAM,aAAa,IAAI,QAAQ,UAAU,qBAAqB;AAC9D,YAAM,SAAS,UAAU,KAAK,UAAU;AACxC,UAAI,IAAI,KAAK;AACX,cAAM,IAAI,qBAAqB,IAAI,MAAM;AACzC,YAAI,GAAG;AACL,cAAI,IAAI,IAAI,YAAY;AACtB,gBAAI,IAAI,WAAW,YAAY,IAAI,GAAG;AACtC,qBAAS,IAAI,QAAQ,GAAG,KAAK,GAAG,KAAK;AACnC,kBAAI,EAAE,CAAC,KAAK,MAAM;AAChB,yBAAS,KAAK,YAAY,EAAE,CAAC,EAAE,GAAG;AAAA,cACpC;AAAA,YACF;AAAA,UACF;AACA,YAAE,KAAK,IAAI;AACX,+BAAqB,IAAI,QAAQ,CAAC;AAAA,QACpC,OAAO;AACL,cAAI,IAAI,IAAI,YAAY;AACtB,gBAAI,IAAI,WAAW,YAAY,IAAI,GAAG;AAAA,UACxC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,UAAU;AACZ,YAAQ,eAAe,aAAW;AAChC,YAAM;AAAA,QACJ,OAAO,CAAC;AAAA,MACV,IAAI;AAEJ,UAAI,cAAc,QAAQ,QAAQ,GAAG,MAAM,IAAI;AAC7C,cAAM,aAAa,QAAQ,QAAQ,UAAU,qBAAqB;AAClE,cAAM,aAAa,UAAU,SAAS,UAAU;AAChD,cAAM,QAAQ,KAAK,UAAU,UAAQ,KAAK,QAAQ,QAAQ,OAAO,UAAU,MAAM,UAAU,MAAM,UAAU;AAC3G,YAAI,UAAU,IAAI;AAChB,eAAK,OAAO,OAAO,CAAC;AAAA,QACtB;AAAA,MACF;AACA,WAAK,KAAK,OAAO;AAAA,IACnB;AACA,QAAI,MAAM,QAAQ,MAAM,IAAI,MAAM,OAAO;AACvC,YAAM,MAAM,yDAAyD;AAAA,IACvE;AAAA,EACF;AACA,SAAO,kBAAkB,YAAY,UAAU;AAAA,IAC7C,OAAO;AAAA,IACP,IAAI,WAAW;AACb,aAAO,MAAM;AAAA,IACf;AAAA,EACF,CAAC;AACH;AACA,MAAM,UAAU,CAAC,KAAK,OAAO,YAAY;AACvC,QAAM,KAAK,eAAe;AAC1B,QAAM,IAAI,WAAW,WAAW;AAChC,MAAI,CAAC;AAAG,UAAM,IAAI,MAAM,wCAAwC;AAChE,UAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,IAAI,OAAO;AACT,aAAO,MAAM,QAAQ,MAAM;AAAA,IAC7B;AAAA,EACF,CAAC;AACD,SAAO;AACT;AACA,SAAS;AACF,gBAAS,QAAQ,SAAS;AAC/B,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,WAAW,WAAW;AAC1B,qBAAmB,MAAM;AACvB,QAAI,CAAC,UAAU;AACb,UAAI,QAAQ,aAAa,OAAO;AAChC,gBAAU,MAAM,gBAAgB,SAAS,KAAK,CAAC;AAAA,IACjD;AAAA,EACF,CAAC;AACD,MAAI,UAAU;AACZ,iBAAa,OAAO;AACpB,WAAO;AAAA,EACT;AACF;AACO,gBAAS,WAAW,MAAM;AAC/B,SAAO,KAAK,IAAI,SAAO;AACrB,UAAM,OAAO,OAAO,KAAK,IAAI,KAAK;AAClC,UAAM,QAAQ,KAAK,IAAI,OAAK,MAAM,aAAa,KAAK,IAAI,CAAC;AAAA,IAEzD,OAAO,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE;AACtC,UAAM,WAAW,IAAI,MAAM;AAC3B,QAAI,IAAI,SAAS,OAAO;AACtB,aAAO,IAAI,IAAI,GAAG,aAAa,IAAI,EAAE,IAAI,KAAK;AAAA,MAE9C,IAAI,SAAS,SAAS,OAAO,QAAQ,IAAI,YAAY,EAAE,KAAK,IAAI,GAAG;AAAA,IACrE;AACA,WAAO,IAAI,IAAI,GAAG,aAAa,IAAI,EAAE,IAAI,KAAK;AAAA,EAChD,CAAC,EAAE,KAAK,EAAE;AACZ;AACO,aAAM,QAAQ,WAAS,QAAQ,SAAS,OAAO;AAAA,EACpD,QAAQ;AAAA,EACR,OAAO;AACT,CAAC;AACM,aAAM,QAAQ,WAAS,QAAQ,SAAS,OAAO;AAAA,EACpD,OAAO;AACT,CAAC;AACM,aAAM,OAAO,WAAS,QAAQ,QAAQ,KAAK;AAC3C,aAAM,OAAO,WAAS,QAAQ,QAAQ,KAAK;AAC3C,aAAM,OAAO,WAAS,QAAQ,QAAQ,KAAK;AAC3C,aAAM,aAAa,WAAS,kBAAkB,MAAM,aAAa;AAAA,EACtE,KAAK;AACP,GAAG,KAAK,CAAC;",
        "names": []
      }
    },
    {
      "name": "vite:json",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\nconst titleTagProperties = [];\nconst metaTagProperties = (\n  // https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element\n  [\"name\", \"http-equiv\", \"content\", \"charset\", \"media\"].concat([\"property\"])\n);\nconst getTagKey = (tag, properties) => {\n  const tagProps = Object.fromEntries(Object.entries(tag.props).filter(([k]) => properties.includes(k)).sort());\n  if (Object.hasOwn(tagProps, \"name\") || Object.hasOwn(tagProps, \"property\")) {\n    tagProps.name = tagProps.name || tagProps.property;\n    delete tagProps.property;\n  }\n  return tag.tag + JSON.stringify(tagProps);\n};\nconst MetaProvider = (props) => {\n  if (!isServer && !sharedConfig.context) {\n    const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n    Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\n  }\n  const cascadedTagInstances = /* @__PURE__ */ new Map();\n  function getElement(tag) {\n    if (tag.ref) {\n      return tag.ref;\n    }\n    let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n    if (el) {\n      if (el.tagName.toLowerCase() !== tag.tag) {\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        }\n        el = document.createElement(tag.tag);\n      }\n      el.removeAttribute(\"data-sm\");\n    } else {\n      el = document.createElement(tag.tag);\n    }\n    return el;\n  }\n  const actions = {\n    addClientTag: (tag) => {\n      if (cascadingTags.indexOf(tag.tag) !== -1) {\n        const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagKey = getTagKey(tag, properties);\n        if (!cascadedTagInstances.has(tagKey)) {\n          cascadedTagInstances.set(tagKey, []);\n        }\n        let instances = cascadedTagInstances.get(tagKey);\n        let index = instances.length;\n        instances = [...instances, tag];\n        cascadedTagInstances.set(tagKey, instances);\n        if (!isServer) {\n          let element = getElement(tag);\n          tag.ref = element;\n          spread(element, tag.props);\n          let lastVisited = null;\n          for (var i = index - 1; i >= 0; i--) {\n            if (instances[i] != null) {\n              lastVisited = instances[i];\n              break;\n            }\n          }\n          if (element.parentNode != document.head) {\n            document.head.appendChild(element);\n          }\n          if (lastVisited && lastVisited.ref) {\n            document.head.removeChild(lastVisited.ref);\n          }\n        }\n        return index;\n      }\n      if (!isServer) {\n        let element = getElement(tag);\n        tag.ref = element;\n        spread(element, tag.props);\n        if (element.parentNode != document.head) {\n          document.head.appendChild(element);\n        }\n      }\n      return -1;\n    },\n    removeClientTag: (tag, index) => {\n      const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n      const tagKey = getTagKey(tag, properties);\n      if (tag.ref) {\n        const t = cascadedTagInstances.get(tagKey);\n        if (t) {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n            for (let i = index - 1; i >= 0; i--) {\n              if (t[i] != null) {\n                document.head.appendChild(t[i].ref);\n              }\n            }\n          }\n          t[index] = null;\n          cascadedTagInstances.set(tagKey, t);\n        } else {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n          }\n        }\n      }\n    }\n  };\n  if (isServer) {\n    actions.addServerTag = (tagDesc) => {\n      const {\n        tags = []\n      } = props;\n      if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n        const properties = tagDesc.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagDescKey = getTagKey(tagDesc, properties);\n        const index = tags.findIndex((prev) => prev.tag === tagDesc.tag && getTagKey(prev, properties) === tagDescKey);\n        if (index !== -1) {\n          tags.splice(index, 1);\n        }\n      }\n      tags.push(tagDesc);\n    };\n    if (Array.isArray(props.tags) === false) {\n      throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n    }\n  }\n  return _$createComponent(MetaContext.Provider, {\n    value: actions,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst MetaTag = (tag, props, setting) => {\n  const id = createUniqueId();\n  const c = useContext(MetaContext);\n  if (!c)\n    throw new Error(\"<MetaProvider /> should be in the tree\");\n  useHead({\n    tag,\n    props,\n    setting,\n    id,\n    get name() {\n      return props.name || props.property;\n    }\n  });\n  return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n  const {\n    addClientTag,\n    removeClientTag,\n    addServerTag\n  } = useContext(MetaContext);\n  createRenderEffect(() => {\n    if (!isServer) {\n      let index = addClientTag(tagDesc);\n      onCleanup(() => removeClientTag(tagDesc, index));\n    }\n  });\n  if (isServer) {\n    addServerTag(tagDesc);\n    return null;\n  }\n}\nexport function renderTags(tags) {\n  return tags.map((tag) => {\n    const keys = Object.keys(tag.props);\n    const props = keys.map((k) => k === \"children\" ? \"\" : ` ${k}=\"${// @ts-expect-error\n    escape(tag.props[k], true)}\"`).join(\"\");\n    const children = tag.props.children;\n    if (tag.setting?.close) {\n      return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${// @ts-expect-error\n      tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n    }\n    return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n  }).join(\"\");\n}\nexport const Title = (props) => MetaTag(\"title\", props, {\n  escape: true,\n  close: true\n});\nexport const Style = (props) => MetaTag(\"style\", props, {\n  close: true\n});\nexport const Meta = (props) => MetaTag(\"meta\", props);\nexport const Link = (props) => MetaTag(\"link\", props);\nexport const Base = (props) => MetaTag(\"base\", props);\nexport const Stylesheet = (props) => _$createComponent(Link, _$mergeProps({\n  rel: \"stylesheet\"\n}, props));\n",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\nconst titleTagProperties = [];\nconst metaTagProperties = (\n  // https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element\n  [\"name\", \"http-equiv\", \"content\", \"charset\", \"media\"].concat([\"property\"])\n);\nconst getTagKey = (tag, properties) => {\n  const tagProps = Object.fromEntries(Object.entries(tag.props).filter(([k]) => properties.includes(k)).sort());\n  if (Object.hasOwn(tagProps, \"name\") || Object.hasOwn(tagProps, \"property\")) {\n    tagProps.name = tagProps.name || tagProps.property;\n    delete tagProps.property;\n  }\n  return tag.tag + JSON.stringify(tagProps);\n};\nconst MetaProvider = (props) => {\n  if (!isServer && !sharedConfig.context) {\n    const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n    Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\n  }\n  const cascadedTagInstances = /* @__PURE__ */ new Map();\n  function getElement(tag) {\n    if (tag.ref) {\n      return tag.ref;\n    }\n    let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n    if (el) {\n      if (el.tagName.toLowerCase() !== tag.tag) {\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        }\n        el = document.createElement(tag.tag);\n      }\n      el.removeAttribute(\"data-sm\");\n    } else {\n      el = document.createElement(tag.tag);\n    }\n    return el;\n  }\n  const actions = {\n    addClientTag: (tag) => {\n      if (cascadingTags.indexOf(tag.tag) !== -1) {\n        const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagKey = getTagKey(tag, properties);\n        if (!cascadedTagInstances.has(tagKey)) {\n          cascadedTagInstances.set(tagKey, []);\n        }\n        let instances = cascadedTagInstances.get(tagKey);\n        let index = instances.length;\n        instances = [...instances, tag];\n        cascadedTagInstances.set(tagKey, instances);\n        if (!isServer) {\n          let element = getElement(tag);\n          tag.ref = element;\n          spread(element, tag.props);\n          let lastVisited = null;\n          for (var i = index - 1; i >= 0; i--) {\n            if (instances[i] != null) {\n              lastVisited = instances[i];\n              break;\n            }\n          }\n          if (element.parentNode != document.head) {\n            document.head.appendChild(element);\n          }\n          if (lastVisited && lastVisited.ref) {\n            document.head.removeChild(lastVisited.ref);\n          }\n        }\n        return index;\n      }\n      if (!isServer) {\n        let element = getElement(tag);\n        tag.ref = element;\n        spread(element, tag.props);\n        if (element.parentNode != document.head) {\n          document.head.appendChild(element);\n        }\n      }\n      return -1;\n    },\n    removeClientTag: (tag, index) => {\n      const properties = tag.tag === \"title\" ? titleTagProperties : metaTagProperties;\n      const tagKey = getTagKey(tag, properties);\n      if (tag.ref) {\n        const t = cascadedTagInstances.get(tagKey);\n        if (t) {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n            for (let i = index - 1; i >= 0; i--) {\n              if (t[i] != null) {\n                document.head.appendChild(t[i].ref);\n              }\n            }\n          }\n          t[index] = null;\n          cascadedTagInstances.set(tagKey, t);\n        } else {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n          }\n        }\n      }\n    }\n  };\n  if (isServer) {\n    actions.addServerTag = (tagDesc) => {\n      const {\n        tags = []\n      } = props;\n      if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n        const properties = tagDesc.tag === \"title\" ? titleTagProperties : metaTagProperties;\n        const tagDescKey = getTagKey(tagDesc, properties);\n        const index = tags.findIndex((prev) => prev.tag === tagDesc.tag && getTagKey(prev, properties) === tagDescKey);\n        if (index !== -1) {\n          tags.splice(index, 1);\n        }\n      }\n      tags.push(tagDesc);\n    };\n    if (Array.isArray(props.tags) === false) {\n      throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n    }\n  }\n  return _$createComponent(MetaContext.Provider, {\n    value: actions,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst MetaTag = (tag, props, setting) => {\n  const id = createUniqueId();\n  const c = useContext(MetaContext);\n  if (!c)\n    throw new Error(\"<MetaProvider /> should be in the tree\");\n  useHead({\n    tag,\n    props,\n    setting,\n    id,\n    get name() {\n      return props.name || props.property;\n    }\n  });\n  return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n  const {\n    addClientTag,\n    removeClientTag,\n    addServerTag\n  } = useContext(MetaContext);\n  createRenderEffect(() => {\n    if (!isServer) {\n      let index = addClientTag(tagDesc);\n      onCleanup(() => removeClientTag(tagDesc, index));\n    }\n  });\n  if (isServer) {\n    addServerTag(tagDesc);\n    return null;\n  }\n}\nexport function renderTags(tags) {\n  return tags.map((tag) => {\n    const keys = Object.keys(tag.props);\n    const props = keys.map((k) => k === \"children\" ? \"\" : ` ${k}=\"${// @ts-expect-error\n    escape(tag.props[k], true)}\"`).join(\"\");\n    const children = tag.props.children;\n    if (tag.setting?.close) {\n      return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${// @ts-expect-error\n      tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n    }\n    return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n  }).join(\"\");\n}\nexport const Title = (props) => MetaTag(\"title\", props, {\n  escape: true,\n  close: true\n});\nexport const Style = (props) => MetaTag(\"style\", props, {\n  close: true\n});\nexport const Meta = (props) => MetaTag(\"meta\", props);\nexport const Link = (props) => MetaTag(\"link\", props);\nexport const Base = (props) => MetaTag(\"base\", props);\nexport const Stylesheet = (props) => _$createComponent(Link, _$mergeProps({\n  rel: \"stylesheet\"\n}, props));\n",
      "start": 1767441590049,
      "end": 1767441590049,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
