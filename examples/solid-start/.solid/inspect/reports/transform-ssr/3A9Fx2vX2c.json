{
  "resolvedId": "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/createRouteAction.tsx",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { useNavigate, useSearchParams, type Navigator } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl, FormProps } from \"./Form\";\n\nimport type { ParentComponent } from \"solid-js\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\n\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\n\nexport type RouteAction<T, U> = [\n  {\n    pending: boolean;\n    input?: T;\n    result?: U;\n    error?: any;\n    clear: () => void;\n    retry: () => void;\n  },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\nexport type RouteMultiAction<T, U> = [\n  Submission<T, U>[] & { pending: Submission<T, U>[] },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\n\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\n\nexport function createRouteAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{ data?: U; error?: any } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p\n      .then(async data => {\n        if (reqId === count) {\n          if (data instanceof Response) {\n            await handleResponse(data, navigate, options);\n          } else await handleRefetch(data as unknown as any[], options);\n          if (!data || isRedirectResponse(data)) setInput(undefined);\n          else setResult({ data });\n        }\n        return data;\n      })\n      .catch(async e => {\n        if (reqId === count) {\n          if (e instanceof Response) {\n            await handleResponse(e, navigate, options);\n          }\n          if (!isRedirectResponse(e)) {\n            setResult({ error: e });\n          } else setInput(undefined);\n        }\n        return undefined;\n      }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: Omit<FormProps, \"action\" | \"onSubmission\">) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    {\n      get pending() {\n        return !!input() && !result();\n      },\n      get input() {\n        return input();\n      },\n      get result() {\n        return result()?.data;\n      },\n      get error(): any {\n        return result()?.error;\n      },\n      clear() {\n        batch(() => {\n          setInput(undefined);\n          setResult(undefined);\n        });\n      },\n      retry() {\n        const variables = input();\n        if (!variables) throw new Error(\"No submission to retry\");\n        submit(variables);\n      }\n    },\n    submit\n  ];\n}\n\nexport function createRouteMultiAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteMultiAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(\n    init.input ? [createSubmission(init.input)[0]] : []\n  );\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T,\n      readonly result: U | undefined,\n      readonly error: Error | undefined,\n      clear(): void,\n      retry(): void\n    };\n    const [result, setResult] = createSignal<{ data?: U; error?: any }>();\n    return [\n      (submission = {\n        input: variables,\n        get result() {\n          return result()?.data;\n        },\n        get error() {\n          return result()?.error;\n        },\n        clear() {\n          setSubmissions(v => v.filter(i => i.input !== variables));\n        },\n        retry() {\n          setResult(undefined);\n          return event && handleSubmit(fn(variables, event));\n        }\n      }),\n      handleSubmit\n    ] as const;\n    function handleSubmit(p: Promise<Response & { body: U } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as unknown as any[], options);\n        data ? setResult({ data }) : submission.clear();\n\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({ error: e });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    new Proxy<Submission<T, U>[] & { pending: Submission<T, U>[] }>([] as any, {\n      get(_, property) {\n        if (property === $TRACK) return submissions();\n        if (property === \"pending\") return submissions().filter(sub => !sub.result);\n        return submissions()[property as keyof typeof submissions];\n      }\n    }),\n    submit\n  ];\n}\n\nfunction handleRefetch(response: Response | string | any[], options: { invalidate?: Invalidate } = {}) {\n  return refetchRouteData(\n    typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate\n  );\n}\n\nfunction handleResponse(response: Response, navigate: Navigator, options?: { invalidate?: Invalidate }) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n\n  return handleRefetch(response, options);\n}\n\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error\n        ? new FormError(param.error.message, {\n            fieldErrors: param.error.fieldErrors,\n            stack: param.error.stack,\n            form: param.error.form,\n            fields: param.error.fields\n          })\n        : undefined\n    },\n    input: input as unknown as T\n  };\n}\n",
      "start": 1767441590410,
      "end": 1767441590410
    },
    {
      "name": "solid-start-file-system-router",
      "start": 1767441590410,
      "end": 1767441590410,
      "order": "pre"
    },
    {
      "name": "solid",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { useNavigate, useSearchParams } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl, FormProps } from \"./Form\";\nimport type { ParentComponent } from \"solid-js\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\nexport type RouteAction<T, U> = [{\n  pending: boolean;\n  input?: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}, ((vars: T) => Promise<U | undefined>) & {\n  Form: ParentComponent<FormProps | T>;\n  url: string;\n}];\nexport type RouteMultiAction<T, U> = [Submission<T, U>[] & {\n  pending: Submission<T, U>[];\n}, ((vars: T) => Promise<U | undefined>) & {\n  Form: ParentComponent<FormProps | T>;\n  url: string;\n}];\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\nexport function createRouteAction<T = void, U = void>(fn: (arg1: void, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options: {\n  invalidate?: Invalidate;\n} = {}): RouteAction<T, U> {\n  let init: {\n    result?: {\n      data?: U;\n      error?: any;\n    };\n    input?: T;\n  } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{\n    data?: U;\n    error?: any;\n  } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p.then(async data => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else await handleRefetch(data as unknown as any[], options);\n        if (!data || isRedirectResponse(data)) setInput(undefined);else setResult({\n          data\n        });\n      }\n      return data;\n    }).catch(async e => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else setInput(undefined);\n      }\n      return undefined;\n    }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: Omit<FormProps, \"action\" | \"onSubmission\">) => {\n    let url = (fn as any).url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData as any);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  }) as ParentComponent<FormProps | T>;\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error(): any {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(undefined);\n        setResult(undefined);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables) throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction<T = void, U = void>(fn: (arg1: void, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options: {\n  invalidate?: Invalidate;\n} = {}): RouteMultiAction<T, U> {\n  let init: {\n    result?: {\n      data?: U;\n      error?: any;\n    };\n    input?: T;\n  } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T;\n      readonly result: U | undefined;\n      readonly error: Error | undefined;\n      clear(): void;\n      retry(): void;\n    };\n    const [result, setResult] = createSignal<{\n      data?: U;\n      error?: any;\n    }>();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions(v => v.filter(i => i.input !== variables));\n      },\n      retry() {\n        setResult(undefined);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit] as const;\n    function handleSubmit(p: Promise<Response & {\n      body: U;\n    } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as unknown as any[], options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData as any);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  }) as ParentComponent<FormProps | T>;\n  return [new Proxy<Submission<T, U>[] & {\n    pending: Submission<T, U>[];\n  }>([] as any, {\n    get(_, property) {\n      if (property === $TRACK) return submissions();\n      if (property === \"pending\") return submissions().filter(sub => !sub.result);\n      return submissions()[property as keyof typeof submissions];\n    }\n  }), submit];\n}\nfunction handleRefetch(response: Response | string | any[], options: {\n  invalidate?: Invalidate;\n} = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate);\n}\nfunction handleResponse(response: Response, navigate: Navigator, options?: {\n  invalidate?: Invalidate;\n}) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  return handleRefetch(response, options);\n}\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : undefined\n    },\n    input: input as unknown as T\n  };\n}",
      "start": 1767441590410,
      "end": 1767441590479,
      "order": "pre",
      "sourcemaps": {
        "version": 3,
        "names": [
          "useNavigate",
          "useSearchParams",
          "$TRACK",
          "batch",
          "createSignal",
          "useContext",
          "FormError",
          "FormImpl",
          "FormProps",
          "ParentComponent",
          "isRedirectResponse",
          "ServerContext",
          "useRequest",
          "ServerFunctionEvent",
          "refetchRouteData",
          "ActionEvent",
          "Submission",
          "input",
          "T",
          "result",
          "U",
          "error",
          "clear",
          "retry",
          "RouteAction",
          "pending",
          "vars",
          "Promise",
          "Form",
          "url",
          "RouteMultiAction",
          "Invalidate",
          "r",
          "Response",
          "createRouteAction",
          "fn",
          "arg1",
          "event",
          "options",
          "invalidate",
          "args",
          "init",
          "data",
          "checkFlash",
          "setInput",
          "setResult",
          "navigate",
          "count",
          "submit",
          "variables",
          "p",
          "reqId",
          "undefined",
          "then",
          "handleResponse",
          "handleRefetch",
          "catch",
          "e",
          "props",
          "Omit",
          "_$createComponent",
          "_$mergeProps",
          "action",
          "onSubmission",
          "submission",
          "formData",
          "children",
          "Error",
          "createRouteMultiAction",
          "submissions",
          "setSubmissions",
          "createSubmission",
          "v",
          "filter",
          "i",
          "handleSubmit",
          "const",
          "body",
          "s",
          "Proxy",
          "get",
          "_",
          "property",
          "sub",
          "response",
          "Navigator",
          "locationUrl",
          "headers",
          "startsWith",
          "window",
          "location",
          "href",
          "params",
          "param",
          "form",
          "JSON",
          "parse",
          "Map",
          "entries",
          "message",
          "fieldErrors",
          "stack",
          "fields"
        ],
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/createRouteAction.tsx"
        ],
        "sourcesContent": [
          "import { useNavigate, useSearchParams, type Navigator } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl, FormProps } from \"./Form\";\n\nimport type { ParentComponent } from \"solid-js\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\n\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\n\nexport type RouteAction<T, U> = [\n  {\n    pending: boolean;\n    input?: T;\n    result?: U;\n    error?: any;\n    clear: () => void;\n    retry: () => void;\n  },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\nexport type RouteMultiAction<T, U> = [\n  Submission<T, U>[] & { pending: Submission<T, U>[] },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\n\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\n\nexport function createRouteAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{ data?: U; error?: any } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p\n      .then(async data => {\n        if (reqId === count) {\n          if (data instanceof Response) {\n            await handleResponse(data, navigate, options);\n          } else await handleRefetch(data as unknown as any[], options);\n          if (!data || isRedirectResponse(data)) setInput(undefined);\n          else setResult({ data });\n        }\n        return data;\n      })\n      .catch(async e => {\n        if (reqId === count) {\n          if (e instanceof Response) {\n            await handleResponse(e, navigate, options);\n          }\n          if (!isRedirectResponse(e)) {\n            setResult({ error: e });\n          } else setInput(undefined);\n        }\n        return undefined;\n      }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: Omit<FormProps, \"action\" | \"onSubmission\">) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    {\n      get pending() {\n        return !!input() && !result();\n      },\n      get input() {\n        return input();\n      },\n      get result() {\n        return result()?.data;\n      },\n      get error(): any {\n        return result()?.error;\n      },\n      clear() {\n        batch(() => {\n          setInput(undefined);\n          setResult(undefined);\n        });\n      },\n      retry() {\n        const variables = input();\n        if (!variables) throw new Error(\"No submission to retry\");\n        submit(variables);\n      }\n    },\n    submit\n  ];\n}\n\nexport function createRouteMultiAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteMultiAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(\n    init.input ? [createSubmission(init.input)[0]] : []\n  );\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T,\n      readonly result: U | undefined,\n      readonly error: Error | undefined,\n      clear(): void,\n      retry(): void\n    };\n    const [result, setResult] = createSignal<{ data?: U; error?: any }>();\n    return [\n      (submission = {\n        input: variables,\n        get result() {\n          return result()?.data;\n        },\n        get error() {\n          return result()?.error;\n        },\n        clear() {\n          setSubmissions(v => v.filter(i => i.input !== variables));\n        },\n        retry() {\n          setResult(undefined);\n          return event && handleSubmit(fn(variables, event));\n        }\n      }),\n      handleSubmit\n    ] as const;\n    function handleSubmit(p: Promise<Response & { body: U } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as unknown as any[], options);\n        data ? setResult({ data }) : submission.clear();\n\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({ error: e });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    new Proxy<Submission<T, U>[] & { pending: Submission<T, U>[] }>([] as any, {\n      get(_, property) {\n        if (property === $TRACK) return submissions();\n        if (property === \"pending\") return submissions().filter(sub => !sub.result);\n        return submissions()[property as keyof typeof submissions];\n      }\n    }),\n    submit\n  ];\n}\n\nfunction handleRefetch(response: Response | string | any[], options: { invalidate?: Invalidate } = {}) {\n  return refetchRouteData(\n    typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate\n  );\n}\n\nfunction handleResponse(response: Response, navigate: Navigator, options?: { invalidate?: Invalidate }) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n\n  return handleRefetch(response, options);\n}\n\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error\n        ? new FormError(param.error.message, {\n            fieldErrors: param.error.fieldErrors,\n            stack: param.error.stack,\n            form: param.error.form,\n            fields: param.error.fields\n          })\n        : undefined\n    },\n    input: input as unknown as T\n  };\n}\n"
        ],
        "mappings": "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",
        "ignoreList": []
      }
    },
    {
      "name": "vite:css",
      "start": 1767441590479,
      "end": 1767441590479,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { useNavigate, useSearchParams } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl } from \"./Form\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { refetchRouteData } from \"./createRouteData\";\nexport function createRouteAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [input, setInput] = createSignal(init.input);\n  const [result, setResult] = createSignal(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(void 0);\n      setInput(() => variables);\n    });\n    return p.then(async (data) => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else\n          await handleRefetch(data, options);\n        if (!data || isRedirectResponse(data))\n          setInput(void 0);\n        else\n          setResult({\n            data\n          });\n      }\n      return data;\n    }).catch(async (e) => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else\n          setInput(void 0);\n      }\n      return void 0;\n    });\n  }\n  submit.url = fn.url;\n  submit.Form = (props) => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: (submission) => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error() {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(void 0);\n        setResult(void 0);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables)\n        throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [submissions, setSubmissions] = createSignal(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables) {\n    let submission;\n    const [result, setResult] = createSignal();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions((v) => v.filter((i) => i.input !== variables));\n      },\n      retry() {\n        setResult(void 0);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit];\n    function handleSubmit(p) {\n      p.then(async (data) => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else\n          await handleRefetch(data, options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async (e) => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else\n          await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else\n          submission.clear();\n      });\n      return p;\n    }\n  }\n  function submit(variables) {\n    if (!event) {\n      throw new Error(\"submit was called without an event\");\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions((s) => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = fn.url;\n  submit.Form = (props) => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: (submission) => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [new Proxy([], {\n    get(_, property) {\n      if (property === $TRACK)\n        return submissions();\n      if (property === \"pending\")\n        return submissions().filter((sub) => !sub.result);\n      return submissions()[property];\n    }\n  }), submit];\n}\nfunction handleRefetch(response, options = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response) : options.invalidate);\n}\nfunction handleResponse(response, navigate, options) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  return handleRefetch(response, options);\n}\nfunction checkFlash(fn) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== fn.url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : void 0\n    },\n    input\n  };\n}\n",
      "start": 1767441590479,
      "end": 1767441590559,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "/Users/mac/oss/better-auth-studio/examples/solid/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/createRouteAction.tsx"
        ],
        "sourcesContent": [
          "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { useNavigate, useSearchParams } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl, FormProps } from \"./Form\";\nimport type { ParentComponent } from \"solid-js\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\nexport type RouteAction<T, U> = [{\n  pending: boolean;\n  input?: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}, ((vars: T) => Promise<U | undefined>) & {\n  Form: ParentComponent<FormProps | T>;\n  url: string;\n}];\nexport type RouteMultiAction<T, U> = [Submission<T, U>[] & {\n  pending: Submission<T, U>[];\n}, ((vars: T) => Promise<U | undefined>) & {\n  Form: ParentComponent<FormProps | T>;\n  url: string;\n}];\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\nexport function createRouteAction<T = void, U = void>(fn: (arg1: void, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options: {\n  invalidate?: Invalidate;\n} = {}): RouteAction<T, U> {\n  let init: {\n    result?: {\n      data?: U;\n      error?: any;\n    };\n    input?: T;\n  } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{\n    data?: U;\n    error?: any;\n  } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p.then(async data => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else await handleRefetch(data as unknown as any[], options);\n        if (!data || isRedirectResponse(data)) setInput(undefined);else setResult({\n          data\n        });\n      }\n      return data;\n    }).catch(async e => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else setInput(undefined);\n      }\n      return undefined;\n    }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: Omit<FormProps, \"action\" | \"onSubmission\">) => {\n    let url = (fn as any).url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData as any);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  }) as ParentComponent<FormProps | T>;\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error(): any {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(undefined);\n        setResult(undefined);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables) throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction<T = void, U = void>(fn: (arg1: void, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options?: {\n  invalidate?: Invalidate;\n}): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(fn: (args: T, event: ActionEvent) => Promise<U>, options: {\n  invalidate?: Invalidate;\n} = {}): RouteMultiAction<T, U> {\n  let init: {\n    result?: {\n      data?: U;\n      error?: any;\n    };\n    input?: T;\n  } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T;\n      readonly result: U | undefined;\n      readonly error: Error | undefined;\n      clear(): void;\n      retry(): void;\n    };\n    const [result, setResult] = createSignal<{\n      data?: U;\n      error?: any;\n    }>();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions(v => v.filter(i => i.input !== variables));\n      },\n      retry() {\n        setResult(undefined);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit] as const;\n    function handleSubmit(p: Promise<Response & {\n      body: U;\n    } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as unknown as any[], options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData as any);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  }) as ParentComponent<FormProps | T>;\n  return [new Proxy<Submission<T, U>[] & {\n    pending: Submission<T, U>[];\n  }>([] as any, {\n    get(_, property) {\n      if (property === $TRACK) return submissions();\n      if (property === \"pending\") return submissions().filter(sub => !sub.result);\n      return submissions()[property as keyof typeof submissions];\n    }\n  }), submit];\n}\nfunction handleRefetch(response: Response | string | any[], options: {\n  invalidate?: Invalidate;\n} = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate);\n}\nfunction handleResponse(response: Response, navigate: Navigator, options?: {\n  invalidate?: Invalidate;\n}) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  return handleRefetch(response, options);\n}\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : undefined\n    },\n    input: input as unknown as T\n  };\n}"
        ],
        "mappings": "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",
        "names": []
      }
    },
    {
      "name": "vite:json",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "solid-start-server",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { useNavigate, useSearchParams } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl } from \"./Form\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { refetchRouteData } from \"./createRouteData\";\nexport function createRouteAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [input, setInput] = createSignal(init.input);\n  const [result, setResult] = createSignal(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(void 0);\n      setInput(() => variables);\n    });\n    return p.then(async (data) => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else\n          await handleRefetch(data, options);\n        if (!data || isRedirectResponse(data))\n          setInput(void 0);\n        else\n          setResult({\n            data\n          });\n      }\n      return data;\n    }).catch(async (e) => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else\n          setInput(void 0);\n      }\n      return void 0;\n    });\n  }\n  submit.url = fn.url;\n  submit.Form = (props) => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: (submission) => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error() {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(void 0);\n        setResult(void 0);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables)\n        throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [submissions, setSubmissions] = createSignal(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables) {\n    let submission;\n    const [result, setResult] = createSignal();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions((v) => v.filter((i) => i.input !== variables));\n      },\n      retry() {\n        setResult(void 0);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit];\n    function handleSubmit(p) {\n      p.then(async (data) => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else\n          await handleRefetch(data, options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async (e) => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else\n          await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else\n          submission.clear();\n      });\n      return p;\n    }\n  }\n  function submit(variables) {\n    if (!event) {\n      throw new Error(\"submit was called without an event\");\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions((s) => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = fn.url;\n  submit.Form = (props) => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: (submission) => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [new Proxy([], {\n    get(_, property) {\n      if (property === $TRACK)\n        return submissions();\n      if (property === \"pending\")\n        return submissions().filter((sub) => !sub.result);\n      return submissions()[property];\n    }\n  }), submit];\n}\nfunction handleRefetch(response, options = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response) : options.invalidate);\n}\nfunction handleResponse(response, navigate, options) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  return handleRefetch(response, options);\n}\nfunction checkFlash(fn) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== fn.url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : void 0\n    },\n    input\n  };\n}\n",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1767441590559,
      "end": 1767441590559,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { useNavigate, useSearchParams } from \"/node_modules/.pnpm/@solidjs+router@0.8.4_solid-js@1.9.10/node_modules/@solidjs/router/dist/index.jsx\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/Form.tsx\";\nimport { isRedirectResponse } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/server/responses.ts\";\nimport { ServerContext, useRequest } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/server/ServerContext.tsx\";\nimport { refetchRouteData } from \"/node_modules/.pnpm/solid-start@0.2.32_@solidjs+meta@0.28.7_solid-js@1.9.10__@solidjs+router@0.8.4_solid-js_982dedeb285275853abac446d7a4179e/node_modules/solid-start/data/createRouteData.tsx\";\nexport function createRouteAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [input, setInput] = createSignal(init.input);\n  const [result, setResult] = createSignal(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(void 0);\n      setInput(() => variables);\n    });\n    return p.then(async (data) => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else\n          await handleRefetch(data, options);\n        if (!data || isRedirectResponse(data))\n          setInput(void 0);\n        else\n          setResult({\n            data\n          });\n      }\n      return data;\n    }).catch(async (e) => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else\n          setInput(void 0);\n      }\n      return void 0;\n    });\n  }\n  submit.url = fn.url;\n  submit.Form = (props) => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: (submission) => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error() {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(void 0);\n        setResult(void 0);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables)\n        throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [submissions, setSubmissions] = createSignal(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables) {\n    let submission;\n    const [result, setResult] = createSignal();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions((v) => v.filter((i) => i.input !== variables));\n      },\n      retry() {\n        setResult(void 0);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit];\n    function handleSubmit(p) {\n      p.then(async (data) => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else\n          await handleRefetch(data, options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async (e) => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else\n          await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else\n          submission.clear();\n      });\n      return p;\n    }\n  }\n  function submit(variables) {\n    if (!event) {\n      throw new Error(\"submit was called without an event\");\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions((s) => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = fn.url;\n  submit.Form = (props) => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: (submission) => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [new Proxy([], {\n    get(_, property) {\n      if (property === $TRACK)\n        return submissions();\n      if (property === \"pending\")\n        return submissions().filter((sub) => !sub.result);\n      return submissions()[property];\n    }\n  }), submit];\n}\nfunction handleRefetch(response, options = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response) : options.invalidate);\n}\nfunction handleResponse(response, navigate, options) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  return handleRefetch(response, options);\n}\nfunction checkFlash(fn) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== fn.url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : void 0\n    },\n    input\n  };\n}\n",
      "start": 1767441590559,
      "end": 1767441590561,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
